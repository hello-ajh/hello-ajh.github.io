<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP文件上传的步骤]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[PHP文件上传的步骤为了更好的学习PHP，我们将极为复杂的PHP的文件上传归纳总结成为了6个步骤。 一、判断是否有错误码 系统返回的错误码详解：错误码说明0 无误，可以继续进行文件上传的后续操作。1 超出上传文件的最大限制，upload_max_filesize = 2Mphp.ini中设置，一般默认为2M。可根据项目中的实际需要来修改2 超出了指定的文件大小，根据项目的业务需求指定上传文件的大小限制3 只有部分文件被上传4 文件没有被上传6 找不到临时文件夹，可能目录不存在或没权限7 文件写入失败，可能磁盘满了或没有权限注：错误码中没有5。 二、自定义判断是否超出文件大小范围 在开发上传功能时。我们作为开发人员，除了php.ini中规定的上传的最大值外。我们通常还会设定一个值，是业务规定的上传大小限制。 三、判断后缀名和mime类型是否符合 MIME(Multipurpose Internet Mail Extensions)是多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。在判断后缀和MIME类型的时候，我们会用到PHP的一个函数in_array(),该函数传入两个参数。第一个参数是要判断的值；第二个参数是范围数组。我们用这个函数来判断文件的后缀名和mime类型是否在允许的范围内。 四、生成文件名 我们的文件上传成功了，不会让它保存原名。因为，有些人在原名中有敏感关键词会违反我国的相关法律和法规。我们可以采用date()、mt_rand()或者unique()生成随机的文件名。 五、判断是否是上传文件 文件上传成功时，系统会将上传的临时文件上传到系统的临时目录中。产生一个临时文件。同时会产生临时文件名。我们需要做的事情是将临时文件移动到系统的指定目录中。而移动前不能瞎移动，或者移动错了都是不科学的。移动前我们需要使用相关函数判断上传的文件是不是临时文件。is_uploaded_file()传入一个参数($_FILES中的缓存文件名)，判断传入的名称是不是上传文件。 六、移动临时文件到指定位置 临时文件是真实的临时文件，我们需要将其移动到我们的网站目录下面了。让我们网站目录的数据，其他人可以访问到。我们使用：move_uploaded_file()。这个函数是将上传文件移动到指定位置，并命名。传入两个参数：第一个参数是指定移动的上传文件；第二个参数是指定的文件夹和名称拼接的字符串。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件上传php.ini]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0php-ini%2F</url>
    <content type="text"><![CDATA[PHP文件上传php.ini 配置项 功能说明file_uploads on为 开启文件上传功能，off为关闭post_max_size 系统允许的POST传参的最大值upload_max_filesize 系统允许的上传文件的最大值memory_limit 内存使用限制 建议尺寸： file_size(文件大小) &lt; upload_max_filesize &lt; post_max_size &lt; memory_limit 另外，需要注意的是脚本执行时间。max_execution_time，这什参数的单位为秒。这个参数是设定脚本的最大执行时间。也可以根据需求做适当的改变。通常不需要来修改，系统默认值即可。超大文件上传的时候，可能会涉及到这一项参数的修改。上传时间太长了，会超时。如果你将此项参数设为0，则是不限制超时时间，不建议使用。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件路径函数]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP文件路径函数 函数名 功能pathinfo 返回文件的各个组成部份basename 返回文件名dirname 文件目录部份parse_url 网址拆解成各部份http_build_query 生成url 中的query字符串http_build_url 生成一个url pathinfo1234567891011array pathinfo ( string $路径)功能：传入文件路径返回文件的各个组成部份$path_parts = pathinfo(&apos;d:/www/index.inc.php&apos;);echo &apos;文件目录名：&apos;.$path_parts[&apos;dirname&apos;].&quot;&lt;br /&gt;&quot;;echo &apos;文件全名：&apos;.$path_parts[&apos;basename&apos;].&quot;&lt;br /&gt;&quot;;echo &apos;文件扩展名：&apos;.$path_parts[&apos;extension&apos;].&quot;&lt;br /&gt;&quot;;echo &apos;不包含扩展的文件名：&apos;.$path_parts[&apos;filename&apos;].&quot;&lt;br /&gt;&quot;; //文件目录名：d:/www文件全名：index.inc.php文件扩展名：php不包含扩展的文件名：index.inc basename12345678910string basename ( string $路径[, string $suffix ])功能：传入路径返回文件名第一个参数传入路径。第二个参数，指定文件名到了指定字符停止。echo &quot;1: &quot;.basename(&quot;d:/www/index.d&quot;, &quot;.d&quot;).PHP_EOL;echo &quot;2: &quot;.basename(&quot;d:/www/index.php&quot;).PHP_EOL;echo &quot;3: &quot;.basename(&quot;d:/www/passwd&quot;).PHP_EOL;//1: index2: index.php3: passwd dirname1234dirname(string $路径) 功能：返回文件路径的文件目录部份echo dirname(__FILE__); //C:\phpStudy\PHPTutorial\WWW parse_url1234567891011121314mixed parse_url ( string $路径 )功能：将网址拆解成各个部份$url = &apos;http://username:password@hostname:9090/path?arg=value#anchor&apos;;var_dump(parse_url($url));//array(8) &#123;[&quot;scheme&quot;]=&gt; string(4) &quot;http&quot;[&quot;host&quot;]=&gt; string(8) &quot;hostname&quot;[&quot;port&quot;]=&gt; int(9090)[&quot;user&quot;]=&gt; string(8) &quot;username&quot;[&quot;pass&quot;]=&gt; string(8) &quot;password&quot;[&quot;path&quot;]=&gt; string(5) &quot;/path&quot;[&quot;query&quot;]=&gt; string(9) &quot;arg=value&quot;[&quot;fragment&quot;]=&gt; string(6) &quot;anchor&quot;&#125; http_build_query12345678910string http_build_query ( mixed $需要处理的数据)功能：生成url 中的query字符串//定义一个关联数组$data = [&apos;username&apos;=&gt;&apos;php&apos;,&apos;area&apos;=&gt;&apos;hubei&apos;];//生成query内容echo http_build_query($data);//username=php&amp;area=hubei http_build_url()功能： 生成一个url 注：PHP_EOL 常量在 windows平台相当于 echo “\r\n”;在unix\linux平台相当于 echo “\n”;在mac平台相当于 echo “\r”;]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件权限设置]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[PHP文件权限设置 函数 功能说明chmod 修改读取模式chgrp 修改用户组chown 修改权限 1234//修改linux 系统/var/wwwroot/某文件权限为755chmod(&quot;/var/wwwroot/index.html&quot;, 755); chmod(&quot;/var/wwwroot/index.html&quot;, &quot;u+rwx,go+rx&quot;); chmod(&quot;/somedir/somefile&quot;, 0755);]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP目录处理函数]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP目录处理函数 函数名 功能opendir 打开文件夹，返回操作资源readdir 读取文件夹资源is_dir 判断是否是文件夹closedir 关闭文件夹操作资源filetype 显示是文件夹还是文件，文件显示file，文件夹显示dir 1234567891011121314151617181920212223242526272829303132//设置打开的目录是D盘$dir = &quot;d:/&quot;;//判断是否是文件夹，是文件夹if (is_dir($dir)) &#123;if ($dh = opendir($dir)) &#123;//读取到最后返回false，停止循环while (($file = readdir($dh)) !== false) &#123;echo &quot;文件名为: $file : 文件的类型是: &quot; . filetype($dir . $file) . &quot;&lt;br /&gt;&quot;;&#125;closedir($dh);&#125;&#125;//文件名为: $RECYCLE.BIN : 文件的类型是: dir文件名为: 1111.txt : 文件的类型是: file文件名为: 2345Downloads : 文件的类型是: dir文件名为: 360downloads : 文件的类型是: dir文件名为: BaiduNetdiskDownload : 文件的类型是: dir文件名为: EFI : 文件的类型是: dir文件名为: jyh : 文件的类型是: dir文件名为: Ksoftware : 文件的类型是: dir文件名为: NetFrameWork : 文件的类型是: dir文件名为: PCGame : 文件的类型是: dir文件名为: Program Files : 文件的类型是: dir文件名为: qqpcmgr_docpro : 文件的类型是: dir文件名为: qycache : 文件的类型是: dir文件名为: System Volume Information : 文件的类型是: dir文件名为: Temp : 文件的类型是: dir文件名为: 原始数据 : 文件的类型是: dir文件名为: 括苍一户一档 : 文件的类型是: dir文件名为: 桌面资料 : 文件的类型是: dir文件名为: 桌面资料2 : 文件的类型是: dir文件名为: 软件安全下载目录 : 文件的类型是: dir]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件常用函数和常量]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[PHP文件常用函数和常量文件目录分割符常量 平台 分割符windows linux /windows 的路径格式为 d:\xxx\xxx 注意：windows支持 d:/xxx/xxxlinux 的路径格式为 /home/xxx/xxx 注意：如果\home\xxx\xxx 在linux上是错误的所以当你开启转义之类的话，转义字符 \ 用一起的话 d:\xxx\xxx 是一样的。判断时候有两个 \ 有的话 再转成一个\ 再把 \ 替换成 /当路径分割，这样在linux上或者windos上的路径就能保持统一了。 常量：DIRECTORY_SEPARATOR在windows上：在Linux上：/ 文件指针操作函数rewind ( resource handle)功能：指针回到开始处fseek ( resource handle, int offset [, int from_where])功能：文件指针向后移动指定字符 filesize 检测文件的大小$filename = ‘c:\Users\dell\Desktop\御坂御坂_new.txt’;echo $filename . ‘文件大小为: ‘ . filesize($filename) . ‘ bytes’;//c:/Users/dell/Desktop/御坂御坂_new.txt文件大小为: 3 bytes 其实还有一些其他操作文件的函数，读取文件函数名 功能file 把整个文件读入一个数组中fgets 从文件指针中读取一行,读到最后返回falsefgetc 从文件指针中读取一个字符，读到最后返回falseftruncate 将文件截断到给定的长度 文件的时间函数函数 功能说明filectime 文件创建时间filemtime 文件修改时间fileatime 文件上次访问时间$filename = ‘c:\Users\dell\Desktop\御坂御坂_new.txt’;if (file_exists($filename)) {echo “文件的上次访问时间是:” . date(“Y-m-d H:i:s”, fileatime($filename)).”“;echo “文件的创建时间是: “ . date(“Y-m-d H:i:s”, filectime($filename)).”“;echo “文件的修改时间是: “ . date(“Y-m-d H:i:s”, filemtime($filename)).”“;}//文件的上次访问时间是:2019-12-10 06:38:36文件的创建时间是: 2019-12-10 06:38:36文件的修改时间是: 2019-12-10 06:38:36]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP检测文件属性函数]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP检测文件属性函数1234567891011121314151617181920bool file_exists ( $指定文件名或者文件路径)功能：文件是否存在。bool is_readable ( $指定文件名或者文件路径)功能：文件是否可读bool is_writeable ( $指定文件名或者文件路径)功能：文件是否可写bool is_executable ( $指定文件名或者文件路径)功能：文件是否可执行bool is_file ( $指定文件名或者文件路径)功能：是否是文件bool is_dir ( $指定文件名或者文件路径)功能：是否是目录void clearstatcache ( void )功能：清楚文件的状态缓存]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件基本操作]]></title>
    <url>%2F2019%2F12%2F23%2FPHP%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[PHP文件基本操作重命名文件1234567bool rename($旧名,$新名);//旧文件名$file = &apos;C:\\Users\\dell\\Desktop\\御坂御坂.txt&apos;;//新文件名$newfile = &apos;C:\\Users\\dell\\Desktop\\御坂御坂_new.txt&apos;;//重命名文件rename($file, $newfile); 复制文件1234567bool copy(源文件,目标文件)//旧文件名$file = &apos;C:\\Users\\dell\\Desktop\\御坂御坂.txt&apos;;//新文件名$newfile = &apos;C:\\Users\\dell\\Desktop\\御坂御坂_new.txt&apos;;//复制文件copy($file, $newfile); 删除文件123456789bool unlink(指定路径的文件)删除文件就是将指定路径的一个文件删除，不过这个删除是直接删除。使用的是windows电脑，你在回收站看不到这个文件。$file = &apos;C:\\Users\\dell\\Desktop\\御坂御坂.txt&apos;;if (unlink($file)) &#123;echo &quot;删除文件 $file 成功!\n&quot;;&#125;else &#123;echo &quot;删除 $file 失败!\n&quot;;&#125;//删除文件 C:\Users\dell\Desktop\御坂御坂.txt 成功!]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件函数]]></title>
    <url>%2F2019%2F12%2F09%2FPHP%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP文件函数PHP读取文件readfile 直接输出文件内容int readfile ( string $文件名) file_get_contents 获取文件内容，成为一个字符串string file_get_contents ( string filename)//假设我们有一个多行的文件叫生成出生年月.py，没有的话你可以新建一个这个文件$filename = ‘C:\Users\dell\Desktop\生成出生年月.py’;//打开这个文件，将文件内容赋值给$filestring$filestring = file_get_contents($filename);//因为每一行有一个回车即\n，我用\n来把这个字符串切割成数组$filearray = explode(“\n”, $filestring);//把切割成的数组循环输出。foreach ($filearray as $key =&gt; $value) {echo $key.’：’.$value.’‘;}//0：import xlrd1：2：from xlutils.copy import copy3：4：workbook = xlrd.open_workbook(‘1.xls’, formatting_info=False)5：6：workbooknew = copy(workbook)7：8：sheetnew = workbooknew.get_sheet(0)9：sheetold = workbook.sheet_by_name(‘Sheet1’)10：ID = 7#身份证的列11：Birthday = 6#出生年月的列12：row_begin = 1#开始列数13：row_end = sheetold.nrows#结束列数14：15：for num in range(row_begin,row_end):16： #sheetnew.write(num,2,sheetold.cell(num,4).value)#将性别复制到人口一行17： year = sheetold.cell(num, ID).value[6:10]18： month = sheetold.cell(num, ID).value[10:12]19： day = sheetold.cell(num, ID).value[12:14]20： sheetnew.write(num,Birthday,year+’-‘+month+’-‘+day)#出生年月21：22：workbooknew.save(‘1copy.xls’) fopen、fread、fclose操作读取文件resource fopen ( string $文件名, string 模式)string fread ( resource $操作资源, int 读取长度)bool fclose ( resource $操作资源 ) 通过上面的函数我们来讲解资源类型的通常操作方式：1.打开资源：fopen2.使用相关函数进行操作：fread3.关闭资源：fclose fopen函数 fopen函数的功能是打开文件，参数主要有两个：1.文件打开的路径2.打开文件的模式返回类型是一个资源类型。资源类型需要其他的函数来操作这个资源。所有的资源有打开就要有关闭！！！ fopen模式说明r 只读方式打开，将文件指针指向文件头。r+ 读写方式打开，将文件指针指向文件头。w 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建w+ 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建a 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建a+ 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之x 创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建x+ 创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建 fread函数 函数的功能的功能是读取打开的文件资源。读取指定长度的文件资源，读取一部份向后移动一部份。至到文件结尾。 fclose函数 fclose函数的功能是关闭资源。资源有打开就有关闭。 打开文件//你可以创建一个NoAlike.txt，以只读模式打开$fp = fopen(‘C:\Users\dell\Desktop\生成出生年月.py’, “r”);//var_dump()操作一下$fp看看效果，输出的是不是只有类型提示的是resourcevar_dump($fp);//resource(5) of type (stream) 读取文件//打开一个文件类型后，读取指定长度$contents = fread($fp, 10);echo $contents;//import xlr 关闭文件fclose($fp); 其他注意事项：模式 说明t windows下将\n转为\r\nb 二进制打开模式 PHP创建和修改文件file_put_contents写入文件int file_put_contents ( string $文件路径, string $写入数据])功能：向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度 fwrite配合fopen进行写入操作int fwrite ( resource $文件资源变量, string $写入的字符串 [, int 长度])注：fwrite的别名函数是fputs$file = ‘C:\Users\dell\Desktop\御坂御坂.txt’;$fp= fopen($file, “w”);$len = fwrite($fp, ‘我是一只来自北方的狼，却在南方冻成了狗’);fclose($fp);print $len .’字节被写入了’; 总结：1.不论有没有新建都会打开文件重新写入2.原有的文件内容会被覆盖掉3.文件不存在会创建 那我们来对比一下以下几个模式的不同：模式说明r 只能读不能使用fwrite写r+ 可操作读、写w 只可以写功能w+ 即可读又可以写 a模式和w模式的不同 总结：模式总结w 每次写入会清除原有文件的内容，文件不存在都会创建a 每次写入都会向文件的尾端追加内容注：a+ 是增强的追加功能。在读取时也可以使用。 x模式和w模式的不同 我们会发现： 1.文件存在的时候使用x模式会报错 3.x+ 是增强的x模式。读取时也可以使用。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP正则表达式]]></title>
    <url>%2F2019%2F12%2F09%2FPHP%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[PHP正则表达式定界符定界符，就是定一个边界，边界已内的就是正则表达示。PHP的正则表达示定界符的规定如下：定界符，不能用a-zA-Z0-9\ 其他的都可以用。必须成对出现，有开始就有结束。例子说明/中间写正则/ 正确$中间写正则$ 正确%中间写正则% 正确^中间写正则^ 正确@中间写正则@ 正确(中间写正则) 错误A中间写正则A 错误 原子原子是正则表达示里面的最小单位，原子说白了就是需要匹配的内容。说明：我们见到的空格、回车、换行、0-9、A-Za-z、中文、标点符号、特殊符号全为原子。 正则匹配函数preg_match()：int preg_match ( string $正则 , string $字符串 [, array &amp;$结果] )功能：根据$正则变量，匹配$字符串变量。如果存在则返回匹配的个数，把匹配到的结果放到$结果变量里。如果没有匹配到结果返回0。$zz = ‘/a/‘;$string = ‘aaaaaaaaaaaa’;if(preg_match($zz, $string, $matches)){echo ‘匹配到了，结果为：’;var_dump($matches);}else{echo ‘没有匹配到’;}//匹配到了，结果为：array(1) { [0]=&gt; string(1) “a” } 特殊标识的原子原子说明\d 匹配一个0-9\D 除了0-9以外的所有字符\w a-zA-Z0-9_\W 除了0-9A-Za-z_以外的所有字符\s 匹配所有空白字符\n \t \r 空格\S 匹配所有非空白字符[ ] 指定范围的原子例：[0-5]表示匹配0-5里面的任意数字，[a-z]表示匹配a-z里面的任意字母[^字符]匹配不在指定区间的字符，如果有不在指定区间的字符，则匹配出来 总结：原子等价式\w [a-zA-Z0-9_]\W [^a-zA-Z0-9_]\d [0-9]\D [^0-9]\s [ \t\n\f\r]\S [^ \t\n\f\r] 元字符元字符功能说明 匹配0次或者多次前面的字符。 匹配1次或多次前面的字符? 前面的字符可有可无. 匹配除了\n以外的所有字符^ 必须要以抑扬符之后的字符串开始$ 必须要以$之前的字符结尾\b 词边界\B 非边界{m} 有且只能出现m次{n,m} 可以出现n到m次{m,} 至少m次，最大次数不限制() 改变优先级或者将某个字符串视为一个整体，匹配到的数据取出来也可以使用它 模式匹配符/ 正则表达示/模式匹配符模式匹配符是放在这句话的最后的。例如：/\w+/s 模式匹配符 功能i 不区分大小写 m 将字符串视为多行正则在匹配的时候，要匹配的目标字符串我们通常视为一行。“行起始”元字符（^）仅仅匹配字符串的起始，“行结束”元字符（$）仅仅匹配字符串的结束。当设定了此修正符，“行起始”和“行结束”除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。注意：如果要匹配的字符串中没有“\n”字符或者模式中没有 ^ 或 $，则设定此修正符没有任何效果。 s 将字符串视为单行,换行符作为普通字符.如果设定了此修正符，模式中的圆点元字符（.）匹配所有的字符，包括换行符。 x 将模式中的空白忽略.1.如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略。2.未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略。 A 强制仅从目标字符串的开头开始匹配.此模式类似于元字符中的^（抑扬符）效果。 D 模式中的美元元字符仅匹配目标字符串的结尾. U 只匹配最近的字符串，不进行全局匹配正则表达式在加上+或*以后，默认是贪婪的，也就是尽可能的最大限度匹配。但是在加上U这个模式匹配符之后，就不会进行全局匹配，只会匹配一次例：正则表达式为：/\d/字符串为：123456789匹配结果为：匹配到了，结果为：array(1) { [0]=&gt; string(1) “1” } 正则表达式为：/\d+/字符串为：123456789匹配结果为：匹配到了，结果为：array(1) { [0]=&gt; string(9) “123456789” } 正则表达式为：/\d*/字符串为：123456789匹配结果为：匹配到了，结果为：array(1) { [0]=&gt; string(9) “123456789” } 正则表达式为：/\d+/U字符串为：123456789匹配结果为：匹配到了，结果为：array(1) { [0]=&gt; string(1) “1” } 正则表达式为：/\d/U字符串为：123456789匹配结果为：匹配到了，结果为：array(1) { [0]=&gt; string(0) “” }//因为是匹配0次及以上，所以在加上U这个模式匹配符之后匹配到的是空字符串]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数组常用函数]]></title>
    <url>%2F2019%2F12%2F09%2FPHP%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP数组常用函数函数 功能 array_shift 弹出数组的第一个元素mixed array_shift ( array &amp;$array ) array_unshift 在数组的开始处压入元素int array_unshift ( array &amp;$数组 , mixed $值1 [, mixed $… ] )$mingren = array(“邓超”, “黄晓明”);$dc = array_unshift($mingren , “宁泽涛”, “钟汉良”); array_push 向数组的末尾处压入元素int array_push ( array &amp;$array , mixed $value1 [, mixed $… ] )$mingren = array(“邓超”, “黄晓明”);$dc = array_push($mingren , “宁泽涛”, “钟汉良”); array_pop 弹出数组的最后一个元素mixed array_pop ( array &amp;$array ) current 读出指针当前位置的值key 读出指针当前位置的键next 指针向下移prev 向上移reset 指针到开始处end 指针到结束处 array_combine() 生成一个数组,用一个数组的值作为键名,另一个数组值作为值range() 创建并返回一个包含指定范围的元素的数组。compact() 创建一个由参数所带变量组成的数组array_fill() 用给定的值生成数组array_chunk() 把一个数组分割为新的数组块array_merge() 把两个或多个数组合并为一个数组array_slice() 在数组中根据条件取出一段值，并返回array_diff() 返回两个数组的差集数组array_search() 在数组中搜索给定的值，如果成功则返回相应的键名array_splice() 把数组中的一部分去掉并用其它值取代array_sum() 计算数组中所有值的和in_array() 检查数组中是否存在某个值array_key_exists() 检查给定的键名或索引是否存在于数组中shuffle() 将数组打乱,保留键值count() 计算数组中的单元数目或对象中的属性个数array_flip() 返回一个键值反转后的数组array_keys() 返回数组所有的键,组成一个数组array_values() 返回数组中所有值，组成一个数组array_reverse() 返回一个元素顺序相反的数组array_count_values() 统计数组中所有的值出现的次数array_rand() 从数组中随机抽取一个或多个元素,注意是键名array_unique() 删除重复值，返回剩余数组sort() 按升序对给定数组的值排序,不保留键名rsort() 对数组逆向排序,不保留键名asort() 对数组排序,保持索引关系arsort() 对数组逆向排序,保持索引关系ksort() 按键名对数组排序krsort() 将数组按照键逆向排序natsort() 用自然顺序算法对数组中的元素排序natcasesort() 自然排序,不区分大小写array_filter() 去掉数组中的空元素或者预定元素extract 将键变为变量名，将值变为变量值]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP异地登录检测]]></title>
    <url>%2F2019%2F12%2F09%2FPHP%E5%BC%82%E5%9C%B0%E7%99%BB%E5%BD%95%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[PHP 异地登录检测通过在数据库中增加session_id，来防止异地登录 1、在数据库的user表中添加session_id字段，用来记录每次登录时候的session_id。2、情景1：用户1已经在A地方登录了账户123，已经在数据库记录了session_id，用户2正在B地方登录账户123，将会将数据库的session_id修改为一个新的session_id，此时用户1的任何操作都会出发公共的控制器，然后判断当前的session_id跟数据库中的session_id是否相同，不同则给出“异地登录”的提示，并且强制下线。（公共控制器相当于其他控制器的父类，判断session_id的操作应该放在公共控制器的初始化方法里，保证每个操作都会进行判断，至少得保证每个操作数据库的操作都要先判断一下session_id是否和数据库相同，一致才允许操作数据库）情景2：只有一个用户1登录账户123，则直接将数据库中的session_id修改为当前的session_id。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP-foreach遍历关联数组]]></title>
    <url>%2F2019%2F12%2F09%2FPHP-foreach%E9%81%8D%E5%8E%86%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[PHP foreach遍历关联数组 foreach的基本语法foreach( 要循环的数组变量 as [键变量 =&gt;] 值变量){//循环的结构体} 遍历关联数组 这是一个固定用法，将要循环的数组放进去。as 是一个固定的关键字后面的键变量是可选的，随意定义一个变量，每次循环的时候，foreach这个语法会把键取出来赋值到键变量里面后面的值变量是必填的。每次循环的时候，会把值放到值变量里面。 $data = [‘fj’ =&gt; ‘凤姐’,‘fr’ =&gt; ‘芙蓉’,];foreach($data as $key =&gt; $value){echo $key . ‘——-‘ . $value . ‘‘;}//fj——-凤姐fr——-芙蓉 遍历多维数组 $data = array(0 =&gt; array(‘中国’ =&gt; ‘china’,‘美国’ =&gt; ‘usa’,‘德国’ =&gt; ‘ Germany’,),1 =&gt; array(‘湖北’ =&gt; ‘hubei’,‘河北’ =&gt; ‘hebei’,‘山东’ =&gt; ‘shandong’,‘山西’ =&gt; ‘sanxi’,),); foreach($data as $value){//外循环为$data二维数组的循环//内循环为$value一维数组的循环foreach($value as $k =&gt; $v){echo $k . ‘—–’ . $v .’‘;}echo ‘———————‘;}//中国—–china美国—–usa 德国—– Germany湖北—–hubei河北—–hebei山东—–shandong 山西—–sanxi]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP-for循环遍历索引数组]]></title>
    <url>%2F2019%2F12%2F09%2FPHP-for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E7%B4%A2%E5%BC%95%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[PHP for循环遍历索引数组因为for循环是一个单纯的计数型循环，而索引数组的下标为整型的数值。因此，我们可以通过for循环来遍历索引数组。 $num = [1,2,3,4,5,6,7,8,9];for($i = 0 ; $i &lt; count($num) ; $i++){echo $num[$i];}//123456789]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数组的计算]]></title>
    <url>%2F2019%2F12%2F09%2FPHP%E6%95%B0%E7%BB%84%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[PHP数组的计算count()int count ( mixed $变量)参数$变量 要求是一个数组或者一个可以被统计的对象 $data = [‘baidu’ =&gt;’百度’,‘ali’ =&gt; ‘阿里’,‘tencent’ =&gt; ‘腾讯’,];echo count($data);//3 $erwei = [[‘baidu’ =&gt;’百度’,‘ali’ =&gt; ‘阿里’,‘tencent’ =&gt; ‘腾讯’,],[‘netease’ =&gt;’网易’,‘sohu’ =&gt; ‘搜狐’,‘sina’ =&gt; ‘新浪’,]];//试试输出一个二维数组个数echo count($erwei);//2 //试试输出二维数组中某个元素的个数echo count($erwei[1]);//3]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数组的定义]]></title>
    <url>%2F2019%2F12%2F09%2FPHP%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[PHP数组的定义索引数组：就是下标全为整型的数组。 向索引数组中增加元素$minren = [‘杨幂’,‘王珞丹’,‘刘亦菲’,‘黄圣依’];$minren[] = ‘范冰冰’;$minren[100] = ‘范爷’;$minren[] = ‘李晨’;echo “";var_dump($minren);echo "“;//array(7) {[0]=&gt;string(6) “杨幂”[1]=&gt;string(9) “王珞丹”[2]=&gt;string(9) “刘亦菲”[3]=&gt;string(9) “黄圣依”[4]=&gt;string(9) “范冰冰”[100]=&gt;string(6) “范爷”[101]=&gt;string(6) “李晨”} 总结：1.向索引数组中增加元素用: 数组变量名[]、数组变量名[键值]这两种方式来增加元素2.键值的增长规则与之前的规则一样。都是最大值加1的原则。 向索引数组中删除元素$minren = array(‘杨幂’,‘王珞丹’,‘刘亦菲’,‘黄圣依’,‘范冰冰’);unset($minren[3]);$minren[] = ‘金星’;echo ‘';var_dump($minren);echo '‘;//array(5) {[0]=&gt;string(6) “杨幂”[1]=&gt;string(9) “王珞丹”[2]=&gt;string(9) “刘亦菲”[4]=&gt;string(9) “范冰冰”[5]=&gt;string(6) “金星”} 总结：1.使用unset删除变量的方式来删除数组里面的值。2.删除了中间的值，并不会让后面的下标向前自动移动。而是原来的值为多少就为多少3.删除掉其中的某个值，新加入的值不会替换掉原来的位置，依然遵循最大值加1的原则。 修改值$minren = array(‘杨幂’,‘王珞丹’,‘刘亦菲’,‘黄圣依’,‘范冰冰’);$minren[5] = ‘范爷’;$minren[2] = ‘亦菲，不要嫁给韩国人好吗？’;echo ‘';var_dump($minren);echo '‘;//array(6) {[0]=&gt;string(6) “杨幂”[1]=&gt;string(9) “王珞丹”[2]=&gt;string(39) “亦菲，不要嫁给韩国人好吗？”[3]=&gt;string(9) “黄圣依”[4]=&gt;string(9) “范冰冰”[5]=&gt;string(6) “范爷”} 总结：1.用变量名[键] = 新值。就把数组中的值定的值修改了。 索引数组的其他声明方式一、直接用之前未声明的变量，用变量名后面接中括号的方式声明数组。//直接写一个变量后面加上中括号，声明变量$qi[] = ‘可口可乐’;$qi[10] =’百事可乐’;echo ‘';var_dump($qi);echo '‘;//array(2) {[0]=&gt;string(12) “可口可乐”[10]=&gt;string(12) “百事可乐”} 二、每次用array()写的太麻烦了，还可以不用写array哟，更简单。$minren = [‘杨幂’,‘王珞丹’,100 =&gt; ‘刘亦菲’,‘黄圣依’,‘范冰冰’];echo ‘';var_dump($minren);echo '‘;//array(5) {[0]=&gt;string(6) “杨幂”[1]=&gt;string(9) “王珞丹”[100]=&gt;string(9) “刘亦菲”[101]=&gt;string(9) “黄圣依”[102]=&gt;string(9) “范冰冰”} 关联数组只要数组里面有一个为字符串的数组，就为关联数组。//声明一下关联数组$rela = array(‘帅’ =&gt; ‘陈奕迅’,‘很帅’ =&gt; ‘黄晓明’,‘灰常灰常帅’ =&gt; ‘宁泽涛’,‘有男人味的大叔’ =&gt; ‘吴秀波’,);//再来玩玩简洁声明$drink = [‘美’ =&gt; ‘凤姐’,‘很美’ =&gt; ‘芙蓉姐姐’,‘verymei’ =&gt; ‘杨幂’,‘心中滴女神呀’ =&gt; ‘华妃’,100 =&gt; ‘孙俪’,‘娘娘’,];// 输出 $relaecho ‘';var_dump($rela);echo '‘;// 输出$drinkecho ‘';var_dump($drink);echo '‘; //array(4) {[“帅”]=&gt;string(9) “陈奕迅”[“很帅”]=&gt;string(9) “黄晓明”[“灰常灰常帅”]=&gt;string(9) “宁泽涛”[“有男人味的大叔”]=&gt;string(9) “吴秀波”}array(6) {[“美”]=&gt;string(6) “凤姐”[“很美”]=&gt;string(12) “芙蓉姐姐”[“verymei”]=&gt;string(6) “杨幂”[“心中滴女神呀”]=&gt;string(6) “华妃”[100]=&gt;string(6) “孙俪”[101]=&gt;string(6) “娘娘”}]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP_String常用函数]]></title>
    <url>%2F2019%2F12%2F09%2FPHP-String%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP String常用函数trim() 删除字符串两端的空格或其他预定义字符var_dump(trim(“\r\n php.cn \r\n”)); rtrim() 删除字符串右边的空格或其他预定义字符var_dump(rtrim(“\r\n php.cn \r\n”));chop() rtrim()的别名 ltrim() 删除字符串左边的空格或其他预定义字符var_dump(ltrim(“\r\n php.cn \r\n”)); dirname() 返回路径中的目录部分（我们把它归在了字符串函数里了）echo dirname(‘c:/test/web/home.php’);//c:/test/web str_pad() 把字符串填充为指定的长度echo str_pad($str, 20, ‘.’); str_repeat() 重复使用指定字符串echo str_repeat(‘.’, 13); str_split() 把字符串分割到数组中print_r(str_split(‘Hello’));//Array ( [0] =&gt; H [1] =&gt; e [2] =&gt; l [3] =&gt; l [4] =&gt; o ) strrev() 反转字符串echo strrev(‘Hello’);//olleH wordwrap() 按照指定长度对字符串进行折行处理 str_shuffle() 随机地打乱字符串中所有字符echo str_shuffle(‘Hello World’); parse_str() 将字符串解析成变量parse_str(‘id=123&amp;name=John%20Adams’,$myArray);print_r($myArray);//Array ( [id] =&gt; 123 [name] =&gt; John Adams ) number_format() 通过千位分组来格式化数字echo number_format(‘1234567890’);//1,234,567,890 strtolower() 字符串转为小写echo strtolower(‘Hello World’);//hello world strtoupper() 字符串转为大写echo strtoupper(‘Hello World’);//HELLO WORLD ucfirst() 字符串首字母大写echo ucfirst(‘hello world’);//Hello world ucwords() 字符串每个单词首字符转为大写echo ucwords(‘hello world’);//Hello World htmlentities() 把字符转为HTML实体 htmlspecialchars() 预定义字符转html编码$str = “This is some bold text.”;echo htmlspecialchars($str);//This is some bold text.//如果直接echo $str，浏览器将会解析标签，将bold变成粗体，再加上htmlspecialchars后，浏览器将不会解析其中的字符串，直接输出 nl2br() \n转义为换行标签echo nl2br(“One line.\nAnother line.”);//One line.//Another line. strip_tags() 剥去 HTML、XML 以及 PHP 的标签echo strip_tags(“Hello World“);//Hello World addcslashes() 在指定的字符前添加反斜线转义字符串中字符$str = “My name is mi”;echo addcslashes($str,’m’);//My na\me is \mi stripcslashes() 删除由addcslashes()添加的反斜线echo stripcslashes(“Hello,\my na\me is Van.”);//Hello,my name is Van. quotemeta() 在字符串中某些预定义的字符前添加反斜线$str = “Hello world.(can you hear me?)”;echo quotemeta($str);//Hello world.(can you hear me?) chr() 从指定的 ASCII 值返回字符echo chr(052);//* ord() 返回字符串第一个字符的 ASCII值echo ord(“hello123”);//104 strcasecmp() 不区分大小写比较两字符串echo strcasecmp(“hello world”,”HELLO WORLD”);//0 strcmp() 区分大小写比较两字符串 strncmp() 比较字符串前n个字符，区分大小写 strncasecmp() 比较字符串前n个字符，不区分大小写int strncasecmp ( string $str1 , string $str2 , int $len ) strnatcmp() 自然顺序法比较字符串长度,区分大小写int strnatcmp ( string $str1 , string $str2 ) strnatcasecmp() 自然顺序法比较字符串长度,不区分大小写int strnatcasecmp ( string $str1 , string $str2 ) chunk_split() 将字符串分成小块str chunk_split(str $body[,int $len[,str $end]]) strtok() 切开字符串str strtok(str $str,str $token) explode() 使用一个字符串为标志分割另一个字符串array explode(str $sep,str $str[,int $limit])$str = “Hello@World@123@456”;print_r(explode(‘@’,$str));//Array ( [0] =&gt; Hello [1] =&gt; World [2] =&gt; 123 [3] =&gt; 456 ) implode() 同join,将数组值用预订字符连接成字符串string implode ( string $glue , array $pieces )$arr = [‘ajh’,’大帅比’,’hhh’];print_r(implode(‘@’,$arr));//ajh@大帅比@hhh substr() 截取字符串string substr ( string $string , int $start [, int $length ] ) str_replace() 字符串替换操作,区分大小写mix str_replace(mix $search,,mix $replace,mix $subject[,int &amp;$num]) str_ireplace() 字符串替换操作,不区分大小写mix str_ireplace ( mix $search , mix $replace , mix $subject [, int &amp;$count ] ) substr_count() 统计一个字符串,在另一个字符串中出现次数int substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] ) substr_replace() 替换字符串中某串为另一个字符串mixed substr_replace ( mixed $string , string $replacement , int $start [, int $length ] ) similar_text() 返回两字符串相同字符的数量int similar_text(str $str1,str $str2) strchr() 返回一个字符串在另一个字符串中开始位置到结束的字符串string strstr ( string $str, string $needle , bool $before_needle ) strrchr() 返回一个字符串在另一个字符串中最后一次出现位置开始到末尾的字符串string strrchr ( string $haystack , mixed $needle ) stristr() 返回一个字符串在另一个字符串中开始位置到结束的字符串，不区分大小写string stristr ( string $haystack , mixed $needle [, bool $before_needle = false ] ) strtr() 转换字符串中的某些字符string strtr ( string $str , string $from , string $to ) strpos() 寻找字符串中某字符最先出现的位置int strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) stripos() 寻找字符串中某字符最先出现的位置,不区分大小写int stripos ( string $haystack , string $needle [, int $offset ] ) strrpos() 寻找某字符串中某字符最后出现的位置int strrpos ( string $haystack , string $needle [, int $offset = 0 ] ) strripos() 寻找某字符串中某字符最后出现的位置,不区分大小写int strripos ( string $haystack , string $needle [, int $offset ] ) strspn() 返回字符串中首次符合mask的子字符串长度int strspn ( string $str1 , string $str2 [, int $start [, int $length ]] ) strcspn() 返回字符串中不符合mask的字符串的长度int strcspn ( string $str1 , string $str2 [, int $start [, int $length ]] ) str_word_count() 统计字符串含有的单词数mix str_word_count(str $str,[]) strlen() 统计字符串长度int strlen(str $str) count_chars() 统计字符串中所有字母出现次数(0..255)mixed count_chars ( string $string [, int $mode ] ) md5() 字符串md5编码$str = “Hello”; echo md5($str)//8b1a9953c4611296a827abf8c47804d7 iconv mb_substr 获取字符串的部分string mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] ) mb_http_output 设置/获取 HTTP 输出字符编码mixed mb_http_output ([ string $encoding = mb_http_output() ] ) mb_strlen 获取字符串的长度mixed mb_strlen ( string $str [, string $encoding = mb_internal_encoding() ] ) iconv 字符串按要求的字符编码来转换string iconv ( string $in_charset , string $out_charset , string $str ) iconv_substr 截取字符串的部分 iconv_get_encoding 获取 iconv 扩展的内部配置变量 mb_substr_count 统计字符串出现的次数 mb_check_encoding 检查字符串在指定的编码里是否有效 mb_strrpos 查找字符串在一个字符串中最后出现的位置 mb_split 使用正则表达式分割多字节字符串 parse_url 解释URL成为一个数组 注：mb_* 和iconv_* 他们可以处理多字节字符，例如：中文。中文主要用的是GBK和utf-8两种编码格式。GBK和utf-8是两个不同的编码委员会对于汉字进行的编码的标准。他们规定GBK是双字节，也就是一个汉字占用2Bytes。utf-8是三字节，一个汉字占用三个字节长度的存储空间。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP文件包含函数]]></title>
    <url>%2F2019%2F12%2F03%2FPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP文件包含函数Include()包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行。 Require()跟include唯一不同的是，当产生错误时候，include下面继续运行而require停止运行了。 Include_once()这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下该文件是否被导入。如果已经执行一遍那么就不重复执行了。 Require_once()这个函数跟require的区别 跟上面我所讲的include和include_once是一样的。所以我就不重复了。 注意：1，少用_once，因为它会消耗更多的资源去做检测的工作。2，特高级Include文件只需要编译一次，因为每次包含include都会再执行一次对应的代码，如何减少include再次执行时，需要重新解析的过程。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP用常量限制用户跳过某些文件]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E7%94%A8%E5%B8%B8%E9%87%8F%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%B7%B3%E8%BF%87%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[PHP用常量限制用户跳过某些文件通过define()函数定义常量，来保证必须包含指定的文件 【情景模拟】假设我们在user.php中必须包含version.php文件，那么可以在version.php中设置一个常量，然后在user.php判断是否有这个常量，如果没有，则给出提示，有则正常执行程序。 123456789101112131415161718version.php&lt;?php//使用define()函数设置常量AUTH为truedefine(&apos;AUTH&apos;,true);?&gt;user.php&lt;?phpinclude &apos;version.php&apos;;//使用defined()函数判断常量是否已经设置//如果未设置常量AUTH，则证明没有包含version.php（或未成功包含version.php）if(!defined(&apos;AUTH&apos;))&#123;echo &apos;非法！非法！你尝试跳过授权文件&apos;;exit;&#125;//已设置常量AUTH，则正常执行程序echo &apos;用户注册&apos;;?&gt;]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP单引号及双引号]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8A%E5%8F%8C%E5%BC%95%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[PHP单引号及双引号：12345678910111213141516171819202122双引号解析变量，但是单引号不解析变量。在双引号里面插入变量，变量后面如果有英文或中文字符，它会把这个字符和变量拼接起来，视为一整个变量。一定要在变量后面接上特殊字符，例如空格等分开。$str = &apos;云母&apos;;echo &quot;$str 飞马&quot;;如果在双引号里面插变量的时候，后面不想有空格，可以拿大括号将变量包起来。$str = &apos;云母&apos;;echo &quot;&#123;$str&#125;飞马&quot;;双引号解析转义字符，单引号不解析转义字符。但，单引号能解析\&apos; 和\例1：$str = &apos;123\&apos;; 右边的单引号将会被转义字符转义，直接输出将会报错例2：$str = &apos;123\\&apos;; 直接输出的结果是123\ 因为右边的\被左边的\转义了单引号效率高于双引号，尽可能使用单引号双号和单引号可以互插！！！双引号当中插入单引号，单引号当中插入变量，这个变量会被解析。神奇的字符串拼接胶水——（.）点，用来拼接字符串。我们将定界符声明字符串视为双引号一样的功能来看待。 想要在两个单引号之间输出一个单引号，需要在单引号前加上转义字符\echo &#39;333\&#39;33&#39; 以上将会输出333&#39;33]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数据类型之自动转换和强制转换]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[PHP数据类型之自动转换和强制转换布尔值的自动类型转换12345671.整型的0为假，其他整型值全为真2.浮点的0.0，布尔值的假。小数点后只要有一个非零的数值即为真。3.空字符串为假，只要里面有一个空格都算真。4.字符串的0，也将其看作是假。其他的都为真5.空数组也将其视为假，只要里面有一个值，就为真。6.空也为假7.未声明成功的资源也为假 总结：布尔值的true参与运算是会变成整型或者浮点的1；布尔值的false参与运算是会变成整型或者浮点的0；字符串开始处是整型或浮点类型的字符，会转成对应的类型参与运算； 强制类型转换强制类型转换有三种方式： 123456789101112131.用后面的三个函数可以完成类型转换，intval()、floatval()、strval()$float = 1.23;$result = intval($float);2.变量前加上()里面写上类型，将它转换后赋值给其他变量$transfer = 12.8;//把浮点变为整型$jieguo = (int)$transfer;3.settype(变量，类型) 直接改变量本身$fo = 250.18;//settype第二个参数是int，你实验的时候要记得第二个参数要为字符串类型settype($fo,&apos;int&apos;); 12345678910以下是强制类型转换时的特点：1.空转为整型会为整型的02.空转为浮点会为浮点的03.空转为字符串会为空字符串‘’4.浮点的123.0转为字符串会为字符串1235.浮点的123.2转为字符串会为字符串的123.26.浮点即使小数点再大，它都会被干掉，会舍掉小数点后面的值7.如果字符串转为整型的时候，如果数值在前面，会将前面的数值拿出来做为整型的转换值。8.settype(变量,&apos;null&apos;); 等价于 unset()一个变量9.$目标变量 = (类型)$操作变量 只会改变目标变量的类型，不会改变原变量的类型，Settype是改变原值]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数据类型之NULL类型]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BNULL%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[PHP数据类型之 NULL类型主要有以下三空情况会产生空（null）类型： 通过变量赋值明确指定为变量的值为NULL$str = null; 一个变量没有给任何值$str; 使用函数unset()将变量销毁掉$str = ‘YMFM’;unset($str); unset()这个函数的功能是毁掉变量。unset(变量)括号中间插入想要毁掉的变量名，这个变量就会被毁掉。 empty()可以向括号中间传入一个变量。这个变量的值如果为false或者为null的话，返回true。 isset()可以向括号中间传入一个或者多个变量，变量与变量间用逗号分开。只要有有一个变量为null，则返回false。否则，则返回true。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php数据类型之查看和判断数据类型]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[PHP数据类型之查看和判断数据类型查看数据类型 1.gettype(传入一个变量) 能够获得变量的类型 2.var_dump(传入一个变量) 输出变类型和值 判断数据类型123456789101112我们使用is_* 系列函数。 is_types这一系列的函数，来进行判断某个东西是不是某个类型。如果是这个类型返回真，不是这个类型返回假。is_int 是否为整型is_bool 是否为布尔is_float 是否是浮点is_string 是否是字符串is_array 是否是数组is_object 是否是对象is_null 是否为空is_resource 是否为资源is_scalar 是否为标量is_numeric 是否为数值类型is_callable 是否为函数]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSONP原理]]></title>
    <url>%2F2019%2F10%2F26%2FJSONP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[JSONP原理 JSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。–来源百度 实例（通过script标签请求跨域脚本，然后在跨域脚本上执行本地的回调函数callback()，并且将JSON数据作为参数传递进回调函数）12345678本地代码：&lt;script type=&quot;text/javascript&quot;&gt;//回调函数function callback(data) &#123; alert(data.message);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:20002/test.js&quot;&gt;&lt;/script&gt; 123远程服务器上的脚本代码：//调用callback函数，并以json数据形式作为参数传递，完成回调callback(&#123;message:&quot;success&quot;&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript正则表达式]]></title>
    <url>%2F2019%2F10%2F24%2FJavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript正则表达式123456创建正则表达式 语法： var 变量 = /正则表达式/匹配模式匹配模式： i 忽略大小写 g 全局匹配模式 test()方法用来检查一个字符串是否符合正则表达式的规则，符合则返回true，否则返回false 检查一个字符串中是否含有a123var reg = /a/iconsole.log(reg.test(&quot;abc&quot;))//trueconsole.log(reg.test(&quot;bc&quot;))//false 检查一个字符串中是否含有a或b或c1234567/* 使用 |和[] 表示或者*/var reg = /a|b|c/;console.log(reg.test(&quot;abc&quot;));console.log(reg.test(&quot;ac&quot;));console.log(reg.test(&quot;bcda&quot;)); 检查一个字符串中是否有字母123456789101112131415161718/* []里的内容也是或的关系 表示查找方括号之间的任何字符。有则返回true [ab] == a|b [a-z]表示任意小写字母 [A-Z]表示任意大写字母 [A-z]表示任意字母 [0-9]表示任意数字*/reg = /[a-z]/console.log(reg.test(&quot;d&quot;));reg = /[A-Z]/console.log(reg.test(&quot;D&quot;));reg = /[A-z]/console.log(reg.test(&quot;d&quot;));console.log(reg.test(&quot;D&quot;));reg = /[0-9]/console.log(reg.test(&quot;abc1&quot;)); 检查一个字符串中是否含有指定字符之外的字符12345678/* [^ ]表示查找任何不在方括号之间的字符。有则返回true*/reg = /[^ab]/;console.log(reg.test(&quot;a&quot;));console.log(reg.test(&quot;b&quot;));console.log(reg.test(&quot;c&quot;));console.log(reg.test(&quot;abc&quot;)); 检查一个字符串中是否含有aaa123456789101112131415/* 量词 - 通过量词可以设置一个内容出现的次数 - 量词只对它前面的一个内容起作用 - &#123;n&#125; 正好出现n次 - &#123;m,n&#125; 出现m到n次，注意：逗号后不能有空格! - &#123;m,&#125; 出现m次以上 - + 至少一个，相当于&#123;1,&#125; - * 0个或多个，相当于&#123;0,&#125; - ? 0个或1个，相当于&#123;0,1&#125;*///连续出现3个avar reg = /a&#123;3&#125;/;console.log(reg.test(&quot;aabc&quot;));//falseconsole.log(reg.test(&quot;aaabc&quot;));//true 检查一个字符串是否以a开头1234567891011121314151617181920/* ^ 表示开头 $ 表示结尾*/reg = /^a/; //匹配开头的aconsole.log(reg.test(&quot;abcd&quot;));console.log(reg.test(&quot;babcd&quot;));reg = /a$/; //匹配结尾的aconsole.log(reg.test(&quot;bcad&quot;));console.log(reg.test(&quot;bcda&quot;));/* 如果在一个正则表达式中同时使用^和$，则要求字符串必须完全符合正则表达式(完全一致)*/reg = /^add$/;console.log(reg.test(&quot;abcd&quot;));//falseconsole.log(reg.test(&quot;bcda&quot;));//falseconsole.log(reg.test(&quot;abcda&quot;));//falseconsole.log(reg.test(&quot;add&quot;));//true 检查一个字符串是否是一个合法的手机号1234567891011121314151617/* 手机号的规则： 11位 1.以1开头 2.第二位3-9任意数字 3.三位以后任意数字9个 ^1[3-9][0-9]&#123;9&#125;$*/var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneReg.test(phoneStr));console.log(phoneReg.test(&quot;17858262960&quot;));console.log(phoneReg.test(&quot;11058262960&quot;));console.log(phoneReg.test(&quot;10058262960&quot;));console.log(phoneReg.test(&quot;12058262960&quot;));console.log(phoneReg.test(&quot;1785826296O&quot;));console.log(phoneReg.test(&quot;178582629601&quot;)); 检查一个字符串中是否含有. 使用转义字符\123456789101112131415161718/* 使用/./表示匹配任意单个字符 在正则表达式中使用\ 作为转义字符 使用/\./匹配单个字符 &apos;.&apos; []中的字符表示字符本身，不需要加转义字符\ 比如：[\.]表示匹配\或者. 而不是只匹配.*/reg = /\./;console.log(reg.test(&quot;.&quot;));//trueconsole.log(reg.test(&quot;abc.bcd&quot;));//trueconsole.log(reg.test(&quot;abcbcd&quot;));//false//在字符串中使用单个\表示转义字符,要输出\必须使用\\reg = /\\/;console.log(&quot;ab.\\&quot;);console.log(reg.test(&quot;ab.\\&quot;)); 其他正则转义规则123456789101112131415161718192021222324252627282930/* \w - 任意字母、数字、_ [A-z0-9_] \W - 除了字母、数字、_ [^A-z0-9_] \d - 任意数字 [0-9] \D - 除了数字 [^0-9] \s - 空格 \S - 除了空格 \b - 单词边界 \B - 除了单词边界*/reg = /\w/;console.log(reg.test(&quot;c&quot;));//trueconsole.log(reg.test(&quot;ac&quot;));//true/* 创建一个正则表达式检查一个字符串中是否含有单词child*/reg = /\bchild\b/;console.log(reg.test(&quot;hello children&quot;));//falseconsole.log(reg.test(&quot;hello child ren&quot;));//trueconsole.log(reg.test(&quot;hello child&quot;));//true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jquery操作元素class]]></title>
    <url>%2F2019%2F09%2F21%2FJquery%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0class%2F</url>
    <content type="text"><![CDATA[Jquery操作元素class 获取class或设置class 通过attr()方法设置的class，会覆盖原有的class 12$(&quot;p&quot;).attr(&quot;class&quot;);//获取class的值$(&quot;P&quot;).attr(&quot;class&quot;, &quot;heigh&quot;);//设置class的值 追加class 通过addClass()方法追加的class，不会覆盖原有的class 1$(&quot;P&quot;).addClass(&apos;btn btn2 btn3&apos;);//追加class，一个或多个 移除class 通过removeClass()方法可以移除一个或多个class 没有传递参数，将会移除所有class 12$(&quot;P&quot;).removeClass(&apos;btn btn2 btn3&apos;);//移除class，一个或多个$(&quot;P&quot;).removeClass();//没有传递参数，将会移除所有class 切换class 通过toggleClass()方法可以切换一个或多个class，如果class有则删除，没有则添加 通过添加参数,可以设置只进行删除或者只进行添加操作. 格式:$(selector).toggleClass(class,switch) switch值为true时,只添加;为false时,只删除 1$(&quot;P&quot;).toggleClass(&apos;btn&apos;);//切换class 判断是否存在某个class 通过hasClass()方法判断是否含有某个class，有则返回true 123$(&quot;p&quot;).hasClass(&quot;another&quot;);//如果含有another，则返回true等价于：$(&quot;p&quot;).is(&quot;.another&quot;);]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jquery操作元素css或属性]]></title>
    <url>%2F2019%2F09%2F21%2FJquery%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0css%E6%88%96%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Jquery操作元素css或属性 Jquery操作元素css12$(&apos;#input&apos;).css(&apos;display&apos;, &apos;none&apos;);//设置元素display = none$(&apos;#input&apos;).css(&apos;display&apos;, &apos;block&apos;);//设置元素display = block Jquery操作元素属性123$(&apos;#inputMail&apos;).attr(&apos;placeholder&apos;, &apos;请输入验证码&apos;);//设置元素的placeholder属性$(&apos;#btnMail&apos;).attr(&#123;disabled: &quot;disabled&quot;&#125;);//设置元素为不可用状态$(&apos;#btnMail&apos;).removeAttr(&quot;disabled&quot;);//删除元素的不可用状态，变为正常状态]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP时间、时间戳相关函数]]></title>
    <url>%2F2019%2F09%2F15%2FPHP%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[时区设置时区date_default_timezone_set(&#39;Asia/shanghai&#39;) 获取当前默认时区date_default_timezone_get() 获取当前的unix时间戳time() 获取指定时期时间戳mktime() mktime()函数可以对一个日期和时间获得一个本地化时间戳。语法格式：int mktime (int $hour [, int $minute [, int $second [, int $month [, int $day [. int$year [, int $.is_dstl.l } ] ] 31 )函数的参数分别表示：时、分、秒、月、日、年、是否为夏令时。 1234567mktime函数的返回结果是一个Unix时间戳，对用户的含义不大，常常与date函数一起完成时间的转换。//获取当前时间时间戳，并转化为&quot;2019-12-02 16:16:46&quot;这种格式echo date(&quot;Y-m-d H:i:s&quot;).&quot;&lt;br&gt;&quot;;//获取今天的10:15:35的时间戳，并转化为&quot;2019-12-02 16:16:46&quot;这种格式echo date(&quot;Y-m-d H:i:s&quot;,mktime(10,15,35,date(&quot;m&quot;),date(&quot;d&quot;),date(&quot;Y&quot;))).&quot;&lt;br&gt;&quot;;//获取30天前的10:15:35的时间戳，并转化为&quot;2019-12-02 16:16:46&quot;这种格式echo date(&quot;Y-m-d H:i:s&quot;,mktime(10,15,35,date(&quot;m&quot;),date(&quot;d&quot;)-30,date(&quot;Y&quot;))).&quot;&lt;br&gt;&quot;; strtotime()【效率比mktime()高】 它的语法格式如下：int strtotime ( string $time [, int $now = time() ] )它能将将英文文本的日期时间描述解析为 Unix 时间戳。参数：1.传入一个字符串的时间2.可选参数为是否传入unix时间戳，如果不传则是当前的unix时间戳。 1234567891011121314//now为现在的当前时间echo strtotime(&quot;now&quot;).&quot;&lt;br /&gt;&quot;;//2000年9月10日echo strtotime(&quot;10 September 2000&quot;).&quot;&lt;br /&gt;&quot;;//当前时间加一天echo strtotime(&quot;+1 day&quot;).&quot;&lt;br /&gt;&quot;;//当前时间加一周echo strtotime(&quot;+1 week&quot;).&quot;&lt;br /&gt;&quot;;//当前时间加一周2天4小时2秒echo strtotime(&quot;+1 week 2 days 4 hours 2 seconds&quot;).&quot;&lt;br /&gt;&quot;;//下一个星期四echo strtotime(&quot;next Thursday&quot;).&quot;&lt;br /&gt;&quot;;//上一个星期一echo strtotime(&quot;last Monday&quot;).&quot;&lt;br /&gt;&quot;; 获取当前系统时间getdate() getdate()用来获取当前系统的时间，或者获得一个时间戳的具体含义。时间戳是一个长整数，表示getdate的语法格式如下所示。array getdate ([ int $timestamp = time() ] )函数的返回值是一个根据timestamp得到的包含有时间信息的数组。如果没有参数，则会返回当前的时间。getdate返回的数组，键名包括时间和日期的完整信息。 1234567891011121314Array([seconds] =&gt; 1 //秒[minutes] =&gt; 10 //分钟[hours] =&gt; 17 //小时[mday] =&gt; 18 //日[wday] =&gt; 0 //星期中的第几天[mon] =&gt; 1 //月[year] =&gt; 2015 //年[yday] =&gt; 17 //年中的第几天[weekday] =&gt; Sunday //星期[month] =&gt; January //月份[0] =&gt; 1421597401 //时间戳) 日期验证函数checkdate() checkdate()可以判断一个输出的日期是否有效。在实际的工作中，我们需要经常用于检测常用于用户提交表单的数据验证。例如：验证用户输入的时间是否正确。函数的语法格式如下：bool checkdate ( int $month , int $day , int $year ) 12checkdate(12, 31, 2018)//Truecheckdate(2, 29, 2011)//False,因为2011年2月没有29号，所以为False 格式化时间戳date() 在PHP中，time()或$_SERVER[‘REQUEST_TIME’]都表示当前时间的时间戳 date(string $format [, int $timestamp ])1date(&apos;Y-m-d H:i:s&apos;, $_SERVER[&apos;REQUEST_TIME&apos;]) format字符 说明 返回值例子 日 — — d 月份中的第几天，有前导零的 2 位数字 01 到 31 D 星期中的第几天，文本表示，3 个字母 Mon 到 Sun j 月份中的第几天，没有前导零 1 到 31 l（“L”的小写字母） 星期几，完整的文本格式 Sunday 到 Saturday N ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加） 1（表示星期一）到 7（表示星期天） S 每月天数后面的英文后缀，2 个字符 st，nd，rd 或者 th*。可以和 *j 一起用 w 星期中的第几天，数字表示 0（表示星期天）到 6（表示星期六） z 年份中的第几天 0 到 365 星期 — — W ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） 例如：42（当年的第 42 周） 月 — — F 月份，完整的文本格式，例如 January 或者 March January 到 December m 数字表示的月份，有前导零 01 到 12 M 三个字母缩写表示的月份 Jan 到 Dec n 数字表示的月份，没有前导零 1 到 12 t 指定的月份有几天 28 到 31 年 — — L 是否为闰年 如果是闰年为 1，否则为 0 o ISO-8601 格式年份数字。这和 Y 的值相同，只除了如果 ISO 的星期数（W）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） Examples: 1999 or 2003 Y 4 位数字完整表示的年份 例如：1999 或 2003 y 2 位数字表示的年份 例如：99 或 03 时间 — — a 小写的上午和下午值 am 或 pm A 大写的上午和下午值 AM 或 PM B Swatch Internet 标准时 000 到 999 g 小时，12 小时格式，没有前导零 1 到 12 G 小时，24 小时格式，没有前导零 0 到 23 h 小时，12 小时格式，有前导零 01 到 12 H 小时，24 小时格式，有前导零 00 到 23 i 有前导零的分钟数 00 到 59&gt; s 秒数，有前导零 00 到 59&gt; u 毫秒 （PHP 5.2.2 新加）。需要注意的是 date() 函数总是返回000000 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 示例: 654321 时区 — — e 时区标识（PHP 5.1.0 新加） 例如：UTC，GMT，Atlantic/Azores I 是否为夏令时 如果是夏令时为 1，否则为 0 O 与格林威治时间相差的小时数 例如：+0200 P 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） 例如：+02:00 T 本机所在的时区 例如：EST，MDT（【译者注】在 Windows 下为完整文本格式，例如“Eastern Standard Time”，中文版会显示“中国标准时间”）。 Z 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 -43200 到 43200 完整的日期／时间 — — c ISO 8601 格式的日期（PHP 5 新加） 2004-02-12T15:19:21+00:00 r RFC 822 格式的日期 例如：Thu, 21 Dec 2000 16:01:07 +0200 U 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数 参见 time()]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git由于远程仓库比较新而无法推送上去]]></title>
    <url>%2F2019%2F09%2F06%2FGit%E7%94%B1%E4%BA%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%AF%94%E8%BE%83%E6%96%B0%E8%80%8C%E6%97%A0%E6%B3%95%E6%8E%A8%E9%80%81%E4%B8%8A%E5%8E%BB%2F</url>
    <content type="text"><![CDATA[Git由于远程仓库比较新而无法推送上去偶尔在执行推指令的时候会出现这个错误讯息： 123456789$ git pushTo https://github.com/hello-ajh/ceshi.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;https://github.com/hello-ajh/ceshi.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 这段讯息的意思是线上版本的内容比你电脑里这份还要新，所以Git不让你推上去。 怎么造成的？ 多人一起开发时： 1、Sherly跟Eddie两个人在差不多的时间都从Git Server上拉了一份资料下来准备进行开发。 2、Sherly手脚比较快，先完成了，于是先把做好的成果推一份上去。 3、Eddie不久后也完成了，但当他要推上去的时候发现推不上去了…… 单人开发时： 1、执行git clone，从远程仓库克隆仓库到本地，此时可以正常推上去 2、此时在远程仓库处新增一个任意文件，就会发现无法推上去 总结：本地仓库在push之前，远程仓库有过（文件、代码）更新，就会出现无法推送的情况 怎么解决？方法一：先拉再推因为你电脑里的内容是比较旧的，所以你应该先拉一份线上版本回来更新，然后再推一次 git pull 此命令会将拉取远程仓库的更新并与本地分支进行合并 例子1：远程仓库比本地仓库多了一个文件“123.txt”，执行上述命令会将“123.txt”克隆到本地仓库 例子2：远程仓库和本地仓库的文件一致，但是同一个文件“123.txt”里面的内容不一致，执行上述命令会将本地的“123.txt”的内容修改为远程仓库的“123.txt”的内容 合并如果没发生，接着就可以推送了 方法二：强制推送（覆盖）（不推荐） git push -f 添加-f会强制推送至远程分支，并且清空所有的提交历史，相当于删除远程仓库，在创建一个新的同名远程仓库，在推送上去。 此命令会覆盖远程仓库的新内容]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git添加远程仓库]]></title>
    <url>%2F2019%2F09%2F05%2FGit%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Git添加远程仓库 初始化本地git项目1git init 添加文件和注释12git add .git commit -m &quot;注释内容&quot; 在add要注意一个地方，如果文件有不需要上传的地方或者较大的文件不需要不好上传可以忽略掉，这就可以在.gitignore文件里面设置 以’#’ 开始的行为注释.忽略掉所有文件名是 test.txt 的文件.test.txt忽略build文件夹build忽略所有生成的备份文件.~忽略所有.o 和 .a文件.*.[oa] 链接远程仓库1git remote add origin 【仓库地址】 更新代码1git pull origin master --allow-unrelated-histories 因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码git pull，这句代码是在git 2.9.2版本发生的，最新的版本需要添加–allow-unrelated-histories假如我们的源是origin，分支是master，那么我们 需要这样写git pull origin master —-allow-unrelated-histories需要知道，我们的源可以是本地的路径。 push至git仓库1git push --set-upstream origin master 全部过程实例：12345678mkdir Helloworldcd Helloworldgit initecho &quot;# Helloworld&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://git.coding.net/xxxxxxx/Helloworld.gitgit push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS相对定位和绝对定位]]></title>
    <url>%2F2019%2F09%2F05%2FCSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[CSS：相对定位（position：relative）和绝对定位（position：absolute） ps：通常情况下，我们元素的position属性的值默认为static 就是没有定位，元素出现在正常的文档流中，这个时候你给这个元素设置的left,right,bottom,top这些偏移属性都是没有效果的，不会生效，比如你设置一个距离左边距偏移100px的声明：left:100px 那么这条声明不会起到任何效果。还有z-index属性在这时也不会生效。 相对定位（relative） 元素相对于自身进行定位（自身为参照物） 1、元素会出现在文档流中它该出现的位置 2、我们可以设置它的水平或垂直偏移量，让这个元素相对于它在文档流中的位置的起始点进行移动 3、在使用相对定位时，就算元素被偏移了，但是他仍然占据着它没偏移前的空间 绝对定位（absolute） 元素相对于设置了除static定位之外的定位（比如position:relative）的第一个祖先元素进行定位，没有这样的祖先元素则相对于body进行定位（并非窗口,相对于窗口定位的是fixed）（祖先元素为参照物） 1、被设置了绝对定位的元素，在文档流中是不占据空间的 2、如果某元素设置了绝对定位，那么它在文档流中的位置会被删除 如果某元素设置了绝对定位，那么它在文档流中的位置会被删除，那这个元素到哪去了呢？它浮了起来，其实设置了相对定位relative时也会让该 元素浮起来，但它们的不同点在于，相对对定位不会删除它本身在文档流中占据的那块空间，而绝对定位则会删除掉该元素在文档流中的位置，完全从文档流中抽了出来]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-DB类操作数据库]]></title>
    <url>%2F2019%2F08%2F27%2FLaravel-DB%E7%B1%BB%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[DB类操作数据库 模型在控制器中的调用 引入DB门面（Facades）：use DB; 执行数据库操作之前需要先指定需要操作的数据表 $db = DB::table(&#39;member&#39;); 基础操作 增加操作 1.insert可以同时增加多行，返回布尔类型，true or false 2.insertGetId只能增加一行，但是自增的id 修改操作 where()-&gt;update(); 返回值为受到影响的行数（修改了多少行） $db-&gt;where(&#39;id&#39;,&#39;1&#39;)-&gt;update([&#39;name&#39;=&gt;&#39;张三丰&#39;]); 查询操作 where()-&gt;get(); $db-&gt;where(&#39;id&#39;,&#39;&gt;&#39;.&#39;3&#39;)-&gt;get(); where使用方法： 123where()-&gt;where()-&gt;where()... 此语法为并且（and）关系where()-&gt;orWhere()-&gt;orWhere()... 此语法为或者（or）关系 first()方法：返回结果集的第一行数据 $db-&gt;get()-&gt;first(); value()方法：返回具体某一个字段 $db-&gt;where(&#39;id&#39;,&#39;&gt;&#39;.&#39;3&#39;)-&gt;value(&#39;name&#39;); select()方法：返回一个值或多个值 $db-&gt;select(&#39;name&#39;,&#39;email&#39;)-&gt;where(&#39;id&#39;,&#39;1&#39;)-&gt;get(); orderBy()方法：排序（desc降序，asc升序） $db-&gt;orderBy(&#39;age&#39;,&#39;desc&#39;)-&gt;get(); 分页操作：limit()和offset() limit表示每页的数量 offset表示从第几条数据开始，0代表第一条数据 $db-&gt;limit(2)-&gt;offset(0)-&gt;get(); 删除操作 $db-&gt;where(&#39;id&#39;,&#39;&lt;&#39;,&#39;4&#39;)-&gt;delete(); 执行任意的SQL语句 （1）执行任意的insert update delete 语句使用statement 【影响记录的语句使用statement语法】 （2）执行任意的select语句使用select 【不影响记录的语句使用select语法】]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Model操作数据库]]></title>
    <url>%2F2019%2F08%2F27%2FLaravel-Model%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Laravel-Model操作数据库 位置：app目录下 命名规则：表名（首字母大写）.php example：Member.php|User.php|Goods.php 创建模型：php artisan make:model User 注意事项： 模型在控制器中的调用 引入Member模型类：use App\Home\Member; 模型的使用：模型在控制器中的使用方式有2种 （1）直接像使用DB门面一样的操作方式，以调用静态方法为主的形式，该形势下模型不需要实例化 123Member::get(); 等价于DB::table(&apos;member&apos;)-&gt;get() （2）实例化模型，然后去使用模型类 123$model = new Member();$model-&gt;get(); 基础操作 添加数据 方式一：（save） 12345$model = new Member();$model-&gt;name = &apos;安佳豪&apos;;$model-&gt;age = &apos;20&apos;;...$model-&gt;save(); 方式二：（create） 1234public function add(Request $request)&#123; $model = new Member(); $model-&gt;create($request-&gt;all());&#125; 查询操作 获取一条数据：find()返回一个对象 12$data = Member::find($id);echo $data-&gt;name; toArray()可以将对象转化为数组 12$data = Member::find($id)-&gt;toArray();echo $data[&apos;name&apos;]; 获取符合指定条件的第一条记录 1Member::where(&apos;id&apos;,&apos;&gt;&apos;,&quot;4&quot;)-&gt;first(); 获取符合指定条件的所有记录 1Member::where(&apos;id&apos;,&apos;&gt;&apos;,&apos;5&apos;)-&gt;get(); 获取指定字段的所有记录 123Member::select(&apos;name&apos;,&apos;age&apos;)-&gt;get();Member::get([&apos;name&apos;,&apos;age&apos;]);Member::all([&apos;name&apos;,&apos;age&apos;]); ps： all（）方法相当于get（）方法，单独使用都是返回所有结果集 注意：all（）方法不支持连接其他的辅助查询方法，而get（）方法则没有这种限制 get（）方法在与其他辅助查询方式连接使用时，需要放在最后 修改操作 方式一：（save） 1234$user = User::find($id);$user-&gt;title = $_POST[&apos;title&apos;];$user-&gt;content = $_POST[&apos;content&apos;];$user-&gt;save(); 方式二：（update） 1Member::where(&apos;id&apos;,&apos;7&apos;)-&gt;update([&apos;age&apos;=&gt;&apos;38&apos;]); 删除操作 方式一： 12$user = User::find($id);$user-&gt;delete(); 方式二： 1Member::where(&apos;id&apos;,&apos;9&apos;)-&gt;delete();]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel填充文件找不到的问题]]></title>
    <url>%2F2019%2F08%2F27%2FLaravel%E5%A1%AB%E5%85%85%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Laravel填充文件找不到的问题 123php artisan db:seed --class=BlogTableSeeder ReflectionException : Class BlogTableSeeder does not exist 填充文件在存在的情况下找不到的原因： composer.json未自动加载这个种子文件 解决方法 执行：composer dumpautoload]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jquery或Js获取元素data-*属性]]></title>
    <url>%2F2019%2F08%2F24%2FJquery%E6%88%96Js%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0data-%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Jquery或Js获取元素data-*属性1&lt;li id=&quot;getId&quot; data-id=&quot;123&quot; data-vice-id=&quot;11&quot;&gt;获取id&lt;/li&gt; Js：getAttribute()/setAttribute()【操作DOM元素属性】1234567891011let li = document.getElementById(&apos;getId&apos;);//取值//getAttribute()获取属性console.log(li.getAttribute(&apos;data-id&apos;));//123console.log(li.getAttribute(&apos;data-vice-id&apos;));//11//赋值//serAttribute()赋值属性li.setAttribute(&apos;data-id&apos;, &apos;234&apos;);console.log(li.getAttribute(&apos;data-id&apos;));//234 Js：dataset【操作DOM元素dataset】12345678910111213141516//取值//data-id通过id获取console.log(li.dataset.id);//123//data-vice-id通过viceId获取，（使用驼峰命名法取值）console.log(li.dataset.viceId);//11//赋值li.dataset.id = &apos;234&apos;;//234li.dataset.viceId = &apos;22&apos;;//22//新增data属性li.dataset.id2 = &apos;100&apos;;//100//删除data属性，（设置data为null，或者delete）li.dataset.id2 = null;//nulldelete li.dataset.id2;//undefind Jquery data()【操作DOM元素dataset】123456//取值let id = $(&apos;#getId&apos;).data(&apos;id&apos;);//123let id = $(&apos;#getId&apos;).data(&apos;vice-id&apos;);//11//赋值$(&apos;#getId&apos;).data(&apos;id&apos;, &apos;100&apos;);//100 注意： 使用Jquery的data()方法修改的data-*属性不会影响到DOM元素上（即不会改变HTML代码），但是修改依旧有效，此时输出data属性也会是修改后的data属性，data()的本质其实是将一个 “cache” 附加到了对象上，并使用了一个特殊的属性名称。 Jquery attr()【操作DOM元素属性】123456//取值let id = $(&apos;#getId&apos;).attr(&apos;data-id&apos;);//123let viceId = $(&apos;#getId&apos;).attr(&apos;data-vice-id&apos;);//11//赋值$(&apos;#getId&apos;).attr(&apos;data-id&apos;, &apos;100&apos;);//100]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel项目安装]]></title>
    <url>%2F2019%2F08%2F23%2Flaravel%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[laravel安装 安装composercomposer 安装PHP 需要满足以下要求 PHP &gt;= 7.1.3 OpenSSL PHP 拓展 PDO PHP 拓展 Mbstring PHP 拓展 Tokenizer PHP 拓展 XML PHP 拓展 Ctype PHP 拓展 JSON PHP 拓展 BCMath PHP 拓展 安装MySQL 安装apache或nginx 安装nodejs，自带npmnodejs 安装laravel，通过composer安装composer global require laravel/installer 创建laravel项目 laravel new blog 或 composer create-project --prefer-dist laravel/laravel blog 启动PHP内置服务 php artisan serve 该命令会在 http://localhost:8000 上启动服务器]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel数据库填充]]></title>
    <url>%2F2019%2F08%2F23%2Flaravel%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"><![CDATA[laravel数据库填充 创建填充php artisan make:seeder UserTableSeeder 运行填充 执行单个填充php artisan db:seed --class=PaperTableSeeder 执行所有填充php artisan db:seed该命令会运行DatabaseSeeder填充文件，可以在该文件中包含所有其他的填充文件，一次性运行 重建数据库，并重新执行填充php artisan migrate:refresh --seed]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel数据库迁移]]></title>
    <url>%2F2019%2F08%2F23%2Flaravel%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[laravel数据库迁移 创建迁移php artisan make:migration create_user_table ps:在当前项目中第一次运行迁移前，需要先执行 php artisan migrate:install 上述命令会在数据库中生成一张migrations数据表，用来记录迁移文件 运行迁移php artisan migrate【已经执行过的迁移文件不会再次执行】 回滚迁移php artisan migrate:rollback【回滚最后一次的迁移操作，回滚操作不删除迁移文件】 重建数据库php artisan migrate:refresh【删除所有数据表，并执行所有迁移】]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——arguments]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript%E2%80%94%E2%80%94arguments%2F</url>
    <content type="text"><![CDATA[JavaScript——arguments 在调用函数时，浏览器每次都会传递进两个隐含的参数： 1.函数的上下文对象this 2.封装实参的对象arguments - arguments是一个类数组对象（类似数组的对象）， 也可以通过索引进行操作， 通过arguments.length来获取长度 - 在调用函数时，我们所传递的实参都会封装到arguments中， - 我们即使不定义形参，也可以通过arguments来使用实参， arguments[0]表示第一个参数 arguments[1]表示第二个参数 - 它里面有一个属性callee，对应当前正在执行的函数的对象 123456function fun()&#123; console.log(arguments.length);//2 console.log(arguments[0]+&quot;~~&quot;+arguments[1]);//1~~2 console.log(arguments.callee);//function fun()&#123;console...&#125;&#125;fun(1, 2);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——this]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript%E2%80%94%E2%80%94this%2F</url>
    <content type="text"><![CDATA[JavaScript——this JavaScript中的上下文对象this，是由调用的对象决定的 以函数的形式调用，this就是window123456function fun()&#123; console.log(this.name);&#125;fun();//以函数的形式调用，this就是window//由于没有全局变量name，所以没有输出 以方法的形式调用，this就是调用方法的对象12345678910//创建一个对象var obj = &#123; name:&quot;孙悟空&quot;, sayName:function () &#123; console.log(this.name); &#125;&#125;;//以方法形式调用this,this指向调用方法的对象 obj.sayName();//输出“孙悟空”]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器]]></title>
    <url>%2F2019%2F08%2F10%2Fmarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[markdown编辑器（兼容github的markdown语法） Typora（本地markdown编辑器）]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel_csrf白名单]]></title>
    <url>%2F2019%2F08%2F09%2Flaravel-csrf%E7%99%BD%E5%90%8D%E5%8D%95%2F</url>
    <content type="text"><![CDATA[laravel_csrf白名单 laravel中如何添加路由白名单？ 在app\Http\Middleware\VerifyCsrfToken.php中添加要作为排除csrf检测的路由]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fontello免费图标]]></title>
    <url>%2F2019%2F07%2F24%2FFontello%E5%85%8D%E8%B4%B9%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[Fontello免费图标 官网fontello 选择图标直接点击想要的图标即可选中，也可以用鼠标拖动进行多选 下载 本地使用将下载下来的压缩包解压并复制到网站的public目录下，然后引入fontello.css 1&lt;link rel=&quot;stylesheet&quot; href=&quot;../css/fontello.css&quot;&gt; 图标展示1&lt;i class=&quot;icon-emo-happy&quot;&gt;&lt;/i&gt; class格式 12icon-namename就是Fontello官网上的name]]></content>
      <categories>
        <category>免费图标</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现返回顶部按钮]]></title>
    <url>%2F2019%2F07%2F24%2FJquery%E5%AE%9E%E7%8E%B0%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[1、创建一个按钮，并设置样式123&lt;button id=&quot;btnTop&quot; class=&quot;p-2 mb-2 bg-danger text-white clearfix&quot; style=&quot;position: fixed; top: 85%; left: 80%; display: none;&quot;&gt;Top&lt;/button&gt; 2、添加jQuery方法此时，这个按钮并没有显示出来，我们需要当页面的滚动条距离最上方有50个像素时，显示“回到顶部”按钮，通过JQuery来实现 123456789101112$(function () &#123; $(window).scroll(function () &#123; if ($(window).scrollTop() &gt;= 50) &#123; //fadeIn淡入效果 $(&apos;#btnTop&apos;).fadeIn(); &#125; else &#123; //fadeOut淡出效果 $(&apos;#btnTop&apos;).fadeOut(); &#125; &#125;); &#125;); 3、添加click事件123$(&apos;#btnTop&apos;).click(function () &#123; $(&apos;html,body&apos;).animate(&#123; scrollTop: 0 &#125;, 500); &#125;);]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo设置]]></title>
    <url>%2F2019%2F07%2F23%2Fhexo%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo设置一、安装Git淘宝的Git地址 二、安装NodejsNodejs 三、通过npm安装HexoNode.js安装成功后，同时会自动安装一个包管理器，称为npm（Node Package Manager）。 什么是npm？npm是一个包管理器，发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。 安装：npm install -g hexo-cli 由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org安装成功后，可以通过以下命令查看cnpm版本：cnpm -v通过cnpm来操作下载速度会得到很大提升，但包的版本不一定是最新的。之后所有的npm都可以换成cnpm 四、本地使用1、创建博客目录hexo init username.github.io 这个username就是仓库的username，同时也是github的username，目的就是访问githubPage时可以直接使用以下方式访问https://username.github.io/示例：https://hello-ajh.github.io/ 2、更换主题在更换主题之前要先切换到username.github.io目录，执行以下命令 这里选择一个比较简洁的主题：nextgit clone https://github.com/theme-next/hexo-theme-next themes/next 之后需要更改username.github.io/_config.yml里面的配置 title: 御坂0416的博客 //你博客的名字author: 御坂0416 //作者名字language: zh-CN //语言 中文theme: next //刚刚安装的主题名称deploy:type: git //使用Git 发布repo: https://github.com/hello-ajh/hello-ajh.github.io.git // 刚创建的Github仓库 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改 3、写文章 hexo new BlogName会在source/_posts目录下生成BlogName.md文件，可以vim或其他Markdown编辑器进行修改。 4、安装hexo-deployer-git自动部署发布工具 npm install hexo-deployer-git --save 5、生成静态文件、清理、重启Hexo hexo clean每次修改文章后，都需要清理一下，hexo g（g代表generate），生成博客静态文件最后也不要忘了通过hexo s重新启动Hexo。hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 6、发布到githubPage测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如果这是你的第一次，终端会让你输入Github 的邮箱和密码，正确输入后，骚等片刻，就会把你的博客上传至Github 了。以后在每次把博客写完后，执行一下这个命令就可以直接发布了，灰常苏胡。 注意：这里会默认通过Git的方式上传到github的仓库，但是会改变原有的目录结构 7、乱码问题 hexo新建的文章为source/_posts/xxx.md，默认编码格式为ANSI，需要使用记事本将其另存为UTF-8格式或者使用sublime将其另存为UTF-8 with BOM格式]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
  </entry>
</search>
