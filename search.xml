<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP用常量限制用户跳过某些文件]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E7%94%A8%E5%B8%B8%E9%87%8F%E9%99%90%E5%88%B6%E7%94%A8%E6%88%B7%E8%B7%B3%E8%BF%87%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[PHP用常量限制用户跳过某些文件通过define()函数定义常量，来保证必须包含指定的文件 【情景模拟】假设我们在user.php中必须包含version.php文件，那么可以在version.php中设置一个常量，然后在user.php判断是否有这个常量，如果没有，则给出提示，有则正常执行程序。 123456789101112131415161718version.php&lt;?php//使用define()函数设置常量AUTH为truedefine(&apos;AUTH&apos;,true);?&gt;user.php&lt;?phpinclude &apos;version.php&apos;;//使用defined()函数判断常量是否已经设置//如果未设置常量AUTH，则证明没有包含version.php（或未成功包含version.php）if(!defined(&apos;AUTH&apos;))&#123;echo &apos;非法！非法！你尝试跳过授权文件&apos;;exit;&#125;//已设置常量AUTH，则正常执行程序echo &apos;用户注册&apos;;?&gt;]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP单引号及双引号]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E5%8D%95%E5%BC%95%E5%8F%B7%E5%8F%8A%E5%8F%8C%E5%BC%95%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[PHP单引号及双引号：12345678910111213141516171819202122双引号解析变量，但是单引号不解析变量。在双引号里面插入变量，变量后面如果有英文或中文字符，它会把这个字符和变量拼接起来，视为一整个变量。一定要在变量后面接上特殊字符，例如空格等分开。$str = &apos;云母&apos;;echo &quot;$str 飞马&quot;;如果在双引号里面插变量的时候，后面不想有空格，可以拿大括号将变量包起来。$str = &apos;云母&apos;;echo &quot;&#123;$str&#125;飞马&quot;;双引号解析转义字符，单引号不解析转义字符。但，单引号能解析\&apos; 和\例1：$str = &apos;123\&apos;; 右边的单引号将会被转义字符转义，直接输出将会报错例2：$str = &apos;123\\&apos;; 直接输出的结果是123\ 因为右边的\被左边的\转义了单引号效率高于双引号，尽可能使用单引号双号和单引号可以互插！！！双引号当中插入单引号，单引号当中插入变量，这个变量会被解析。神奇的字符串拼接胶水——（.）点，用来拼接字符串。我们将定界符声明字符串视为双引号一样的功能来看待。 想要在两个单引号之间输出一个单引号，需要在单引号前加上转义字符\echo &#39;333\&#39;33&#39; 以上将会输出333&#39;33]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数据类型之自动转换和强制转换]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[PHP数据类型之自动转换和强制转换布尔值的自动类型转换12345671.整型的0为假，其他整型值全为真2.浮点的0.0，布尔值的假。小数点后只要有一个非零的数值即为真。3.空字符串为假，只要里面有一个空格都算真。4.字符串的0，也将其看作是假。其他的都为真5.空数组也将其视为假，只要里面有一个值，就为真。6.空也为假7.未声明成功的资源也为假 总结：布尔值的true参与运算是会变成整型或者浮点的1；布尔值的false参与运算是会变成整型或者浮点的0；字符串开始处是整型或浮点类型的字符，会转成对应的类型参与运算； 强制类型转换强制类型转换有三种方式： 123456789101112131.用后面的三个函数可以完成类型转换，intval()、floatval()、strval()$float = 1.23;$result = intval($float);2.变量前加上()里面写上类型，将它转换后赋值给其他变量$transfer = 12.8;//把浮点变为整型$jieguo = (int)$transfer;3.settype(变量，类型) 直接改变量本身$fo = 250.18;//settype第二个参数是int，你实验的时候要记得第二个参数要为字符串类型settype($fo,&apos;int&apos;); 12345678910以下是强制类型转换时的特点：1.空转为整型会为整型的02.空转为浮点会为浮点的03.空转为字符串会为空字符串‘’4.浮点的123.0转为字符串会为字符串1235.浮点的123.2转为字符串会为字符串的123.26.浮点即使小数点再大，它都会被干掉，会舍掉小数点后面的值7.如果字符串转为整型的时候，如果数值在前面，会将前面的数值拿出来做为整型的转换值。8.settype(变量,&apos;null&apos;); 等价于 unset()一个变量9.$目标变量 = (类型)$操作变量 只会改变目标变量的类型，不会改变原变量的类型，Settype是改变原值]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP数据类型之NULL类型]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BNULL%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[PHP数据类型之 NULL类型主要有以下三空情况会产生空（null）类型： 通过变量赋值明确指定为变量的值为NULL$str = null; 一个变量没有给任何值$str; 使用函数unset()将变量销毁掉$str = ‘YMFM’;unset($str); unset()这个函数的功能是毁掉变量。unset(变量)括号中间插入想要毁掉的变量名，这个变量就会被毁掉。 empty()可以向括号中间传入一个变量。这个变量的值如果为false或者为null的话，返回true。 isset()可以向括号中间传入一个或者多个变量，变量与变量间用逗号分开。只要有有一个变量为null，则返回false。否则，则返回true。]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php数据类型之查看和判断数据类型]]></title>
    <url>%2F2019%2F11%2F29%2FPHP%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[PHP数据类型之查看和判断数据类型查看数据类型 1.gettype(传入一个变量) 能够获得变量的类型 2.var_dump(传入一个变量) 输出变类型和值 判断数据类型123456789101112我们使用is_* 系列函数。 is_types这一系列的函数，来进行判断某个东西是不是某个类型。如果是这个类型返回真，不是这个类型返回假。is_int 是否为整型is_bool 是否为布尔is_float 是否是浮点is_string 是否是字符串is_array 是否是数组is_object 是否是对象is_null 是否为空is_resource 是否为资源is_scalar 是否为标量is_numeric 是否为数值类型is_callable 是否为函数]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSONP原理]]></title>
    <url>%2F2019%2F10%2F26%2FJSONP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[JSONP原理 JSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。–来源百度 实例（通过script标签请求跨域脚本，然后在跨域脚本上执行本地的回调函数callback()，并且将JSON数据作为参数传递进回调函数）12345678本地代码：&lt;script type=&quot;text/javascript&quot;&gt;//回调函数function callback(data) &#123; alert(data.message);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:20002/test.js&quot;&gt;&lt;/script&gt; 123远程服务器上的脚本代码：//调用callback函数，并以json数据形式作为参数传递，完成回调callback(&#123;message:&quot;success&quot;&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript正则表达式]]></title>
    <url>%2F2019%2F10%2F24%2FJavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript正则表达式123456创建正则表达式 语法： var 变量 = /正则表达式/匹配模式匹配模式： i 忽略大小写 g 全局匹配模式 test()方法用来检查一个字符串是否符合正则表达式的规则，符合则返回true，否则返回false 检查一个字符串中是否含有a123var reg = /a/iconsole.log(reg.test(&quot;abc&quot;))//trueconsole.log(reg.test(&quot;bc&quot;))//false 检查一个字符串中是否含有a或b或c1234567/* 使用 |和[] 表示或者*/var reg = /a|b|c/;console.log(reg.test(&quot;abc&quot;));console.log(reg.test(&quot;ac&quot;));console.log(reg.test(&quot;bcda&quot;)); 检查一个字符串中是否有字母123456789101112131415161718/* []里的内容也是或的关系 表示查找方括号之间的任何字符。有则返回true [ab] == a|b [a-z]表示任意小写字母 [A-Z]表示任意大写字母 [A-z]表示任意字母 [0-9]表示任意数字*/reg = /[a-z]/console.log(reg.test(&quot;d&quot;));reg = /[A-Z]/console.log(reg.test(&quot;D&quot;));reg = /[A-z]/console.log(reg.test(&quot;d&quot;));console.log(reg.test(&quot;D&quot;));reg = /[0-9]/console.log(reg.test(&quot;abc1&quot;)); 检查一个字符串中是否含有指定字符之外的字符12345678/* [^ ]表示查找任何不在方括号之间的字符。有则返回true*/reg = /[^ab]/;console.log(reg.test(&quot;a&quot;));console.log(reg.test(&quot;b&quot;));console.log(reg.test(&quot;c&quot;));console.log(reg.test(&quot;abc&quot;)); 检查一个字符串中是否含有aaa123456789101112131415/* 量词 - 通过量词可以设置一个内容出现的次数 - 量词只对它前面的一个内容起作用 - &#123;n&#125; 正好出现n次 - &#123;m,n&#125; 出现m到n次，注意：逗号后不能有空格! - &#123;m,&#125; 出现m次以上 - + 至少一个，相当于&#123;1,&#125; - * 0个或多个，相当于&#123;0,&#125; - ? 0个或1个，相当于&#123;0,1&#125;*///连续出现3个avar reg = /a&#123;3&#125;/;console.log(reg.test(&quot;aabc&quot;));//falseconsole.log(reg.test(&quot;aaabc&quot;));//true 检查一个字符串是否以a开头1234567891011121314151617181920/* ^ 表示开头 $ 表示结尾*/reg = /^a/; //匹配开头的aconsole.log(reg.test(&quot;abcd&quot;));console.log(reg.test(&quot;babcd&quot;));reg = /a$/; //匹配结尾的aconsole.log(reg.test(&quot;bcad&quot;));console.log(reg.test(&quot;bcda&quot;));/* 如果在一个正则表达式中同时使用^和$，则要求字符串必须完全符合正则表达式(完全一致)*/reg = /^add$/;console.log(reg.test(&quot;abcd&quot;));//falseconsole.log(reg.test(&quot;bcda&quot;));//falseconsole.log(reg.test(&quot;abcda&quot;));//falseconsole.log(reg.test(&quot;add&quot;));//true 检查一个字符串是否是一个合法的手机号1234567891011121314151617/* 手机号的规则： 11位 1.以1开头 2.第二位3-9任意数字 3.三位以后任意数字9个 ^1[3-9][0-9]&#123;9&#125;$*/var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneReg.test(phoneStr));console.log(phoneReg.test(&quot;17858262960&quot;));console.log(phoneReg.test(&quot;11058262960&quot;));console.log(phoneReg.test(&quot;10058262960&quot;));console.log(phoneReg.test(&quot;12058262960&quot;));console.log(phoneReg.test(&quot;1785826296O&quot;));console.log(phoneReg.test(&quot;178582629601&quot;)); 检查一个字符串中是否含有. 使用转义字符\123456789101112131415161718/* 使用/./表示匹配任意单个字符 在正则表达式中使用\ 作为转义字符 使用/\./匹配单个字符 &apos;.&apos; []中的字符表示字符本身，不需要加转义字符\ 比如：[\.]表示匹配\或者. 而不是只匹配.*/reg = /\./;console.log(reg.test(&quot;.&quot;));//trueconsole.log(reg.test(&quot;abc.bcd&quot;));//trueconsole.log(reg.test(&quot;abcbcd&quot;));//false//在字符串中使用单个\表示转义字符,要输出\必须使用\\reg = /\\/;console.log(&quot;ab.\\&quot;);console.log(reg.test(&quot;ab.\\&quot;)); 其他正则转义规则123456789101112131415161718192021222324252627282930/* \w - 任意字母、数字、_ [A-z0-9_] \W - 除了字母、数字、_ [^A-z0-9_] \d - 任意数字 [0-9] \D - 除了数字 [^0-9] \s - 空格 \S - 除了空格 \b - 单词边界 \B - 除了单词边界*/reg = /\w/;console.log(reg.test(&quot;c&quot;));//trueconsole.log(reg.test(&quot;ac&quot;));//true/* 创建一个正则表达式检查一个字符串中是否含有单词child*/reg = /\bchild\b/;console.log(reg.test(&quot;hello children&quot;));//falseconsole.log(reg.test(&quot;hello child ren&quot;));//trueconsole.log(reg.test(&quot;hello child&quot;));//true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jquery操作元素class]]></title>
    <url>%2F2019%2F09%2F21%2FJquery%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0class%2F</url>
    <content type="text"><![CDATA[Jquery操作元素class 获取class或设置class 通过attr()方法设置的class，会覆盖原有的class 12$(&quot;p&quot;).attr(&quot;class&quot;);//获取class的值$(&quot;P&quot;).attr(&quot;class&quot;, &quot;heigh&quot;);//设置class的值 追加class 通过addClass()方法追加的class，不会覆盖原有的class 1$(&quot;P&quot;).addClass(&apos;btn btn2 btn3&apos;);//追加class，一个或多个 移除class 通过removeClass()方法可以移除一个或多个class 没有传递参数，将会移除所有class 12$(&quot;P&quot;).removeClass(&apos;btn btn2 btn3&apos;);//移除class，一个或多个$(&quot;P&quot;).removeClass();//没有传递参数，将会移除所有class 切换class 通过toggleClass()方法可以切换一个或多个class，如果class有则删除，没有则添加 通过添加参数,可以设置只进行删除或者只进行添加操作. 格式:$(selector).toggleClass(class,switch) switch值为true时,只添加;为false时,只删除 1$(&quot;P&quot;).toggleClass(&apos;btn&apos;);//切换class 判断是否存在某个class 通过hasClass()方法判断是否含有某个class，有则返回true 123$(&quot;p&quot;).hasClass(&quot;another&quot;);//如果含有another，则返回true等价于：$(&quot;p&quot;).is(&quot;.another&quot;);]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jquery操作元素css或属性]]></title>
    <url>%2F2019%2F09%2F21%2FJquery%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0css%E6%88%96%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Jquery操作元素css或属性 Jquery操作元素css12$(&apos;#input&apos;).css(&apos;display&apos;, &apos;none&apos;);//设置元素display = none$(&apos;#input&apos;).css(&apos;display&apos;, &apos;block&apos;);//设置元素display = block Jquery操作元素属性123$(&apos;#inputMail&apos;).attr(&apos;placeholder&apos;, &apos;请输入验证码&apos;);//设置元素的placeholder属性$(&apos;#btnMail&apos;).attr(&#123;disabled: &quot;disabled&quot;&#125;);//设置元素为不可用状态$(&apos;#btnMail&apos;).removeAttr(&quot;disabled&quot;);//删除元素的不可用状态，变为正常状态]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP格式化时间戳date()]]></title>
    <url>%2F2019%2F09%2F15%2FPHP%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E6%88%B3date()%2F</url>
    <content type="text"><![CDATA[PHP格式化时间戳date() 在PHP中，time()或$_SERVER[‘REQUEST_TIME’]都表示当前时间的时间戳 date(string $format [, int $timestamp ])1date(&apos;Y-m-d H:i:s&apos;, $_SERVER[&apos;REQUEST_TIME&apos;]) format字符 说明 返回值例子 日 — — d 月份中的第几天，有前导零的 2 位数字 01 到 31 D 星期中的第几天，文本表示，3 个字母 Mon 到 Sun j 月份中的第几天，没有前导零 1 到 31 l（“L”的小写字母） 星期几，完整的文本格式 Sunday 到 Saturday N ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加） 1（表示星期一）到 7（表示星期天） S 每月天数后面的英文后缀，2 个字符 st，nd，rd 或者 th*。可以和 *j 一起用 w 星期中的第几天，数字表示 0（表示星期天）到 6（表示星期六） z 年份中的第几天 0 到 365 星期 — — W ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） 例如：42（当年的第 42 周） 月 — — F 月份，完整的文本格式，例如 January 或者 March January 到 December m 数字表示的月份，有前导零 01 到 12 M 三个字母缩写表示的月份 Jan 到 Dec n 数字表示的月份，没有前导零 1 到 12 t 指定的月份有几天 28 到 31 年 — — L 是否为闰年 如果是闰年为 1，否则为 0 o ISO-8601 格式年份数字。这和 Y 的值相同，只除了如果 ISO 的星期数（W）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） Examples: 1999 or 2003 Y 4 位数字完整表示的年份 例如：1999 或 2003 y 2 位数字表示的年份 例如：99 或 03 时间 — — a 小写的上午和下午值 am 或 pm A 大写的上午和下午值 AM 或 PM B Swatch Internet 标准时 000 到 999 g 小时，12 小时格式，没有前导零 1 到 12 G 小时，24 小时格式，没有前导零 0 到 23 h 小时，12 小时格式，有前导零 01 到 12 H 小时，24 小时格式，有前导零 00 到 23 i 有前导零的分钟数 00 到 59&gt; s 秒数，有前导零 00 到 59&gt; u 毫秒 （PHP 5.2.2 新加）。需要注意的是 date() 函数总是返回000000 因为它只接受 integer 参数， 而 DateTime::format() 才支持毫秒。 示例: 654321 时区 — — e 时区标识（PHP 5.1.0 新加） 例如：UTC，GMT，Atlantic/Azores I 是否为夏令时 如果是夏令时为 1，否则为 0 O 与格林威治时间相差的小时数 例如：+0200 P 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） 例如：+02:00 T 本机所在的时区 例如：EST，MDT（【译者注】在 Windows 下为完整文本格式，例如“Eastern Standard Time”，中文版会显示“中国标准时间”）。 Z 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的。 -43200 到 43200 完整的日期／时间 — — c ISO 8601 格式的日期（PHP 5 新加） 2004-02-12T15:19:21+00:00 r RFC 822 格式的日期 例如：Thu, 21 Dec 2000 16:01:07 +0200 U 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数 参见 time()]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git由于远程仓库比较新而无法推送上去]]></title>
    <url>%2F2019%2F09%2F06%2FGit%E7%94%B1%E4%BA%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%AF%94%E8%BE%83%E6%96%B0%E8%80%8C%E6%97%A0%E6%B3%95%E6%8E%A8%E9%80%81%E4%B8%8A%E5%8E%BB%2F</url>
    <content type="text"><![CDATA[Git由于远程仓库比较新而无法推送上去偶尔在执行推指令的时候会出现这个错误讯息： 123456789$ git pushTo https://github.com/hello-ajh/ceshi.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;https://github.com/hello-ajh/ceshi.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 这段讯息的意思是线上版本的内容比你电脑里这份还要新，所以Git不让你推上去。 怎么造成的？ 多人一起开发时： 1、Sherly跟Eddie两个人在差不多的时间都从Git Server上拉了一份资料下来准备进行开发。 2、Sherly手脚比较快，先完成了，于是先把做好的成果推一份上去。 3、Eddie不久后也完成了，但当他要推上去的时候发现推不上去了…… 单人开发时： 1、执行git clone，从远程仓库克隆仓库到本地，此时可以正常推上去 2、此时在远程仓库处新增一个任意文件，就会发现无法推上去 总结：本地仓库在push之前，远程仓库有过（文件、代码）更新，就会出现无法推送的情况 怎么解决？方法一：先拉再推因为你电脑里的内容是比较旧的，所以你应该先拉一份线上版本回来更新，然后再推一次 git pull 此命令会将拉取远程仓库的更新并与本地分支进行合并 例子1：远程仓库比本地仓库多了一个文件“123.txt”，执行上述命令会将“123.txt”克隆到本地仓库 例子2：远程仓库和本地仓库的文件一致，但是同一个文件“123.txt”里面的内容不一致，执行上述命令会将本地的“123.txt”的内容修改为远程仓库的“123.txt”的内容 合并如果没发生，接着就可以推送了 方法二：强制推送（覆盖）（不推荐） git push -f 添加-f会强制推送至远程分支，并且清空所有的提交历史，相当于删除远程仓库，在创建一个新的同名远程仓库，在推送上去。 此命令会覆盖远程仓库的新内容]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git添加远程仓库]]></title>
    <url>%2F2019%2F09%2F05%2FGit%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Git添加远程仓库 初始化本地git项目1git init 添加文件和注释12git add .git commit -m &quot;注释内容&quot; 在add要注意一个地方，如果文件有不需要上传的地方或者较大的文件不需要不好上传可以忽略掉，这就可以在.gitignore文件里面设置 以’#’ 开始的行为注释.忽略掉所有文件名是 test.txt 的文件.test.txt忽略build文件夹build忽略所有生成的备份文件.~忽略所有.o 和 .a文件.*.[oa] 链接远程仓库1git remote add origin 【仓库地址】 更新代码1git pull origin master --allow-unrelated-histories 因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码git pull，这句代码是在git 2.9.2版本发生的，最新的版本需要添加–allow-unrelated-histories假如我们的源是origin，分支是master，那么我们 需要这样写git pull origin master —-allow-unrelated-histories需要知道，我们的源可以是本地的路径。 push至git仓库1git push --set-upstream origin master 全部过程实例：12345678mkdir Helloworldcd Helloworldgit initecho &quot;# Helloworld&quot; &gt;&gt; README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://git.coding.net/xxxxxxx/Helloworld.gitgit push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS相对定位和绝对定位]]></title>
    <url>%2F2019%2F09%2F05%2FCSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[CSS：相对定位（position：relative）和绝对定位（position：absolute） ps：通常情况下，我们元素的position属性的值默认为static 就是没有定位，元素出现在正常的文档流中，这个时候你给这个元素设置的left,right,bottom,top这些偏移属性都是没有效果的，不会生效，比如你设置一个距离左边距偏移100px的声明：left:100px 那么这条声明不会起到任何效果。还有z-index属性在这时也不会生效。 相对定位（relative） 元素相对于自身进行定位（自身为参照物） 1、元素会出现在文档流中它该出现的位置 2、我们可以设置它的水平或垂直偏移量，让这个元素相对于它在文档流中的位置的起始点进行移动 3、在使用相对定位时，就算元素被偏移了，但是他仍然占据着它没偏移前的空间 绝对定位（absolute） 元素相对于设置了除static定位之外的定位（比如position:relative）的第一个祖先元素进行定位，没有这样的祖先元素则相对于body进行定位（并非窗口,相对于窗口定位的是fixed）（祖先元素为参照物） 1、被设置了绝对定位的元素，在文档流中是不占据空间的 2、如果某元素设置了绝对定位，那么它在文档流中的位置会被删除 如果某元素设置了绝对定位，那么它在文档流中的位置会被删除，那这个元素到哪去了呢？它浮了起来，其实设置了相对定位relative时也会让该 元素浮起来，但它们的不同点在于，相对对定位不会删除它本身在文档流中占据的那块空间，而绝对定位则会删除掉该元素在文档流中的位置，完全从文档流中抽了出来]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-DB类操作数据库]]></title>
    <url>%2F2019%2F08%2F27%2FLaravel-DB%E7%B1%BB%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[DB类操作数据库 模型在控制器中的调用 引入DB门面（Facades）：use DB; 执行数据库操作之前需要先指定需要操作的数据表 $db = DB::table(&#39;member&#39;); 基础操作 增加操作 1.insert可以同时增加多行，返回布尔类型，true or false 2.insertGetId只能增加一行，但是自增的id 修改操作 where()-&gt;update(); 返回值为受到影响的行数（修改了多少行） $db-&gt;where(&#39;id&#39;,&#39;1&#39;)-&gt;update([&#39;name&#39;=&gt;&#39;张三丰&#39;]); 查询操作 where()-&gt;get(); $db-&gt;where(&#39;id&#39;,&#39;&gt;&#39;.&#39;3&#39;)-&gt;get(); where使用方法： 123where()-&gt;where()-&gt;where()... 此语法为并且（and）关系where()-&gt;orWhere()-&gt;orWhere()... 此语法为或者（or）关系 first()方法：返回结果集的第一行数据 $db-&gt;get()-&gt;first(); value()方法：返回具体某一个字段 $db-&gt;where(&#39;id&#39;,&#39;&gt;&#39;.&#39;3&#39;)-&gt;value(&#39;name&#39;); select()方法：返回一个值或多个值 $db-&gt;select(&#39;name&#39;,&#39;email&#39;)-&gt;where(&#39;id&#39;,&#39;1&#39;)-&gt;get(); orderBy()方法：排序（desc降序，asc升序） $db-&gt;orderBy(&#39;age&#39;,&#39;desc&#39;)-&gt;get(); 分页操作：limit()和offset() limit表示每页的数量 offset表示从第几条数据开始，0代表第一条数据 $db-&gt;limit(2)-&gt;offset(0)-&gt;get(); 删除操作 $db-&gt;where(&#39;id&#39;,&#39;&lt;&#39;,&#39;4&#39;)-&gt;delete(); 执行任意的SQL语句 （1）执行任意的insert update delete 语句使用statement 【影响记录的语句使用statement语法】 （2）执行任意的select语句使用select 【不影响记录的语句使用select语法】]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Model操作数据库]]></title>
    <url>%2F2019%2F08%2F27%2FLaravel-Model%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Laravel-Model操作数据库 位置：app目录下 命名规则：表名（首字母大写）.php example：Member.php|User.php|Goods.php 创建模型：php artisan make:model User 注意事项： 模型在控制器中的调用 引入Member模型类：use App\Home\Member; 模型的使用：模型在控制器中的使用方式有2种 （1）直接像使用DB门面一样的操作方式，以调用静态方法为主的形式，该形势下模型不需要实例化 123Member::get(); 等价于DB::table(&apos;member&apos;)-&gt;get() （2）实例化模型，然后去使用模型类 123$model = new Member();$model-&gt;get(); 基础操作 添加数据 方式一：（save） 12345$model = new Member();$model-&gt;name = &apos;安佳豪&apos;;$model-&gt;age = &apos;20&apos;;...$model-&gt;save(); 方式二：（create） 1234public function add(Request $request)&#123; $model = new Member(); $model-&gt;create($request-&gt;all());&#125; 查询操作 获取一条数据：find()返回一个对象 12$data = Member::find($id);echo $data-&gt;name; toArray()可以将对象转化为数组 12$data = Member::find($id)-&gt;toArray();echo $data[&apos;name&apos;]; 获取符合指定条件的第一条记录 1Member::where(&apos;id&apos;,&apos;&gt;&apos;,&quot;4&quot;)-&gt;first(); 获取符合指定条件的所有记录 1Member::where(&apos;id&apos;,&apos;&gt;&apos;,&apos;5&apos;)-&gt;get(); 获取指定字段的所有记录 123Member::select(&apos;name&apos;,&apos;age&apos;)-&gt;get();Member::get([&apos;name&apos;,&apos;age&apos;]);Member::all([&apos;name&apos;,&apos;age&apos;]); ps： all（）方法相当于get（）方法，单独使用都是返回所有结果集 注意：all（）方法不支持连接其他的辅助查询方法，而get（）方法则没有这种限制 get（）方法在与其他辅助查询方式连接使用时，需要放在最后 修改操作 方式一：（save） 1234$user = User::find($id);$user-&gt;title = $_POST[&apos;title&apos;];$user-&gt;content = $_POST[&apos;content&apos;];$user-&gt;save(); 方式二：（update） 1Member::where(&apos;id&apos;,&apos;7&apos;)-&gt;update([&apos;age&apos;=&gt;&apos;38&apos;]); 删除操作 方式一： 12$user = User::find($id);$user-&gt;delete(); 方式二： 1Member::where(&apos;id&apos;,&apos;9&apos;)-&gt;delete();]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel填充文件找不到的问题]]></title>
    <url>%2F2019%2F08%2F27%2FLaravel%E5%A1%AB%E5%85%85%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Laravel填充文件找不到的问题 123php artisan db:seed --class=BlogTableSeeder ReflectionException : Class BlogTableSeeder does not exist 填充文件在存在的情况下找不到的原因： composer.json未自动加载这个种子文件 解决方法 执行：composer dumpautoload]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jquery或Js获取元素data-*属性]]></title>
    <url>%2F2019%2F08%2F24%2FJquery%E6%88%96Js%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0data-%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Jquery或Js获取元素data-*属性1&lt;li id=&quot;getId&quot; data-id=&quot;123&quot; data-vice-id=&quot;11&quot;&gt;获取id&lt;/li&gt; Js：getAttribute()/setAttribute()【操作DOM元素属性】1234567891011let li = document.getElementById(&apos;getId&apos;);//取值//getAttribute()获取属性console.log(li.getAttribute(&apos;data-id&apos;));//123console.log(li.getAttribute(&apos;data-vice-id&apos;));//11//赋值//serAttribute()赋值属性li.setAttribute(&apos;data-id&apos;, &apos;234&apos;);console.log(li.getAttribute(&apos;data-id&apos;));//234 Js：dataset【操作DOM元素dataset】12345678910111213141516//取值//data-id通过id获取console.log(li.dataset.id);//123//data-vice-id通过viceId获取，（使用驼峰命名法取值）console.log(li.dataset.viceId);//11//赋值li.dataset.id = &apos;234&apos;;//234li.dataset.viceId = &apos;22&apos;;//22//新增data属性li.dataset.id2 = &apos;100&apos;;//100//删除data属性，（设置data为null，或者delete）li.dataset.id2 = null;//nulldelete li.dataset.id2;//undefind Jquery data()【操作DOM元素dataset】123456//取值let id = $(&apos;#getId&apos;).data(&apos;id&apos;);//123let id = $(&apos;#getId&apos;).data(&apos;vice-id&apos;);//11//赋值$(&apos;#getId&apos;).data(&apos;id&apos;, &apos;100&apos;);//100 注意： 使用Jquery的data()方法修改的data-*属性不会影响到DOM元素上（即不会改变HTML代码），但是修改依旧有效，此时输出data属性也会是修改后的data属性，data()的本质其实是将一个 “cache” 附加到了对象上，并使用了一个特殊的属性名称。 Jquery attr()【操作DOM元素属性】123456//取值let id = $(&apos;#getId&apos;).attr(&apos;data-id&apos;);//123let viceId = $(&apos;#getId&apos;).attr(&apos;data-vice-id&apos;);//11//赋值$(&apos;#getId&apos;).attr(&apos;data-id&apos;, &apos;100&apos;);//100]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel项目安装]]></title>
    <url>%2F2019%2F08%2F23%2Flaravel%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[laravel安装 安装composercomposer 安装PHP 需要满足以下要求 PHP &gt;= 7.1.3 OpenSSL PHP 拓展 PDO PHP 拓展 Mbstring PHP 拓展 Tokenizer PHP 拓展 XML PHP 拓展 Ctype PHP 拓展 JSON PHP 拓展 BCMath PHP 拓展 安装MySQL 安装apache或nginx 安装nodejs，自带npmnodejs 安装laravel，通过composer安装composer global require laravel/installer 创建laravel项目 laravel new blog 或 composer create-project --prefer-dist laravel/laravel blog 启动PHP内置服务 php artisan serve 该命令会在 http://localhost:8000 上启动服务器]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel数据库填充]]></title>
    <url>%2F2019%2F08%2F23%2Flaravel%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"><![CDATA[laravel数据库填充 创建填充php artisan make:seeder UserTableSeeder 运行填充 执行单个填充php artisan db:seed --class=PaperTableSeeder 执行所有填充php artisan db:seed该命令会运行DatabaseSeeder填充文件，可以在该文件中包含所有其他的填充文件，一次性运行 重建数据库，并重新执行填充php artisan migrate:refresh --seed]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel数据库迁移]]></title>
    <url>%2F2019%2F08%2F23%2Flaravel%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[laravel数据库迁移 创建迁移php artisan make:migration create_user_table ps:在当前项目中第一次运行迁移前，需要先执行 php artisan migrate:install 上述命令会在数据库中生成一张migrations数据表，用来记录迁移文件 运行迁移php artisan migrate【已经执行过的迁移文件不会再次执行】 回滚迁移php artisan migrate:rollback【回滚最后一次的迁移操作，回滚操作不删除迁移文件】 重建数据库php artisan migrate:refresh【删除所有数据表，并执行所有迁移】]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——arguments]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript%E2%80%94%E2%80%94arguments%2F</url>
    <content type="text"><![CDATA[JavaScript——arguments 在调用函数时，浏览器每次都会传递进两个隐含的参数： 1.函数的上下文对象this 2.封装实参的对象arguments - arguments是一个类数组对象（类似数组的对象）， 也可以通过索引进行操作， 通过arguments.length来获取长度 - 在调用函数时，我们所传递的实参都会封装到arguments中， - 我们即使不定义形参，也可以通过arguments来使用实参， arguments[0]表示第一个参数 arguments[1]表示第二个参数 - 它里面有一个属性callee，对应当前正在执行的函数的对象 123456function fun()&#123; console.log(arguments.length);//2 console.log(arguments[0]+&quot;~~&quot;+arguments[1]);//1~~2 console.log(arguments.callee);//function fun()&#123;console...&#125;&#125;fun(1, 2);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——this]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript%E2%80%94%E2%80%94this%2F</url>
    <content type="text"><![CDATA[JavaScript——this JavaScript中的上下文对象this，是由调用的对象决定的 以函数的形式调用，this就是window123456function fun()&#123; console.log(this.name);&#125;fun();//以函数的形式调用，this就是window//由于没有全局变量name，所以没有输出 以方法的形式调用，this就是调用方法的对象12345678910//创建一个对象var obj = &#123; name:&quot;孙悟空&quot;, sayName:function () &#123; console.log(this.name); &#125;&#125;;//以方法形式调用this,this指向调用方法的对象 obj.sayName();//输出“孙悟空”]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器]]></title>
    <url>%2F2019%2F08%2F10%2Fmarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[markdown编辑器（兼容github的markdown语法） Typora（本地markdown编辑器）]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[laravel_csrf白名单]]></title>
    <url>%2F2019%2F08%2F09%2Flaravel-csrf%E7%99%BD%E5%90%8D%E5%8D%95%2F</url>
    <content type="text"><![CDATA[laravel_csrf白名单 laravel中如何添加路由白名单？ 在app\Http\Middleware\VerifyCsrfToken.php中添加要作为排除csrf检测的路由]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fontello免费图标]]></title>
    <url>%2F2019%2F07%2F24%2FFontello%E5%85%8D%E8%B4%B9%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[Fontello免费图标 官网fontello 选择图标直接点击想要的图标即可选中，也可以用鼠标拖动进行多选 下载 本地使用将下载下来的压缩包解压并复制到网站的public目录下，然后引入fontello.css 1&lt;link rel=&quot;stylesheet&quot; href=&quot;../css/fontello.css&quot;&gt; 图标展示1&lt;i class=&quot;icon-emo-happy&quot;&gt;&lt;/i&gt; class格式 12icon-namename就是Fontello官网上的name]]></content>
      <categories>
        <category>免费图标</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现返回顶部按钮]]></title>
    <url>%2F2019%2F07%2F24%2FJquery%E5%AE%9E%E7%8E%B0%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[1、创建一个按钮，并设置样式123&lt;button id=&quot;btnTop&quot; class=&quot;p-2 mb-2 bg-danger text-white clearfix&quot; style=&quot;position: fixed; top: 85%; left: 80%; display: none;&quot;&gt;Top&lt;/button&gt; 2、添加jQuery方法此时，这个按钮并没有显示出来，我们需要当页面的滚动条距离最上方有50个像素时，显示“回到顶部”按钮，通过JQuery来实现 123456789101112$(function () &#123; $(window).scroll(function () &#123; if ($(window).scrollTop() &gt;= 50) &#123; //fadeIn淡入效果 $(&apos;#btnTop&apos;).fadeIn(); &#125; else &#123; //fadeOut淡出效果 $(&apos;#btnTop&apos;).fadeOut(); &#125; &#125;); &#125;); 3、添加click事件123$(&apos;#btnTop&apos;).click(function () &#123; $(&apos;html,body&apos;).animate(&#123; scrollTop: 0 &#125;, 500); &#125;);]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo设置]]></title>
    <url>%2F2019%2F07%2F23%2Fhexo%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo设置一、安装Git淘宝的Git地址 二、安装NodejsNodejs 三、通过npm安装HexoNode.js安装成功后，同时会自动安装一个包管理器，称为npm（Node Package Manager）。 什么是npm？npm是一个包管理器，发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。 安装：npm install -g hexo-cli 由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org安装成功后，可以通过以下命令查看cnpm版本：cnpm -v通过cnpm来操作下载速度会得到很大提升，但包的版本不一定是最新的。之后所有的npm都可以换成cnpm 四、本地使用1、创建博客目录hexo init username.github.io 这个username就是仓库的username，同时也是github的username，目的就是访问githubPage时可以直接使用以下方式访问https://username.github.io/示例：https://hello-ajh.github.io/ 2、更换主题在更换主题之前要先切换到username.github.io目录，执行以下命令 这里选择一个比较简洁的主题：nextgit clone https://github.com/theme-next/hexo-theme-next themes/next 之后需要更改username.github.io/_config.yml里面的配置 title: 御坂0416的博客 //你博客的名字author: 御坂0416 //作者名字language: zh-CN //语言 中文theme: next //刚刚安装的主题名称deploy:type: git //使用Git 发布repo: https://github.com/hello-ajh/hello-ajh.github.io.git // 刚创建的Github仓库 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改 3、写文章 hexo new BlogName会在source/_posts目录下生成BlogName.md文件，可以vim或其他Markdown编辑器进行修改。 4、安装hexo-deployer-git自动部署发布工具 npm install hexo-deployer-git --save 5、生成静态文件、清理、重启Hexo hexo clean每次修改文章后，都需要清理一下，hexo g（g代表generate），生成博客静态文件最后也不要忘了通过hexo s重新启动Hexo。hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 6、发布到githubPage测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如果这是你的第一次，终端会让你输入Github 的邮箱和密码，正确输入后，骚等片刻，就会把你的博客上传至Github 了。以后在每次把博客写完后，执行一下这个命令就可以直接发布了，灰常苏胡。 注意：这里会默认通过Git的方式上传到github的仓库，但是会改变原有的目录结构 7、乱码问题 hexo新建的文章为source/_posts/xxx.md，默认编码格式为ANSI，需要使用记事本将其另存为UTF-8格式或者使用sublime将其另存为UTF-8 with BOM格式]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
  </entry>
</search>
